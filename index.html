<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>テキストエフェクト</title>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;500&display=swap" rel="stylesheet">
    <style>
        @font-face {
            font-family: 'Storyteller';
            src: url('path/to/Storyteller-Regular.woff2') format('woff2'),
                 url('path/to/Storyteller-Regular.woff') format('woff');
            /* Storytellerフォントのパスを正確に指定してください */
            /* 必要であれば他の形式 (e.g., .ttf) も追加 */
            font-weight: normal;
            font-style: normal;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #E81F27; /* 背景色を#E81F27に変更 */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Oswald', sans-serif; /* 文章のフォントをOswaldに設定 */
            font-weight: 500; /* Oswald Mediumに相当 */
            color: #000000; /* 文字色を黒に設定 */
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            overflow: hidden;
        }

        .text-wrapper {
            position: absolute; /* 親コンテナの中央に配置 */
            width: 80vw;
            max-width: 1200px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* 中央寄せ */
            line-height: 1.2;
            letter-spacing: 0.08em;
            font-size: 14px;
            opacity: 1;
            pointer-events: none;
            text-align: center;
            transition: opacity 0.5s ease-out;
            /* 初期は文字を直接含むため、flex関連は不要 */
        }

        /* 文字を個別のspanに分ける前の、HTML本来のテキストフローをシミュレートする隠し要素 */
        /* これにより、正確な文字の位置情報を取得する */
        #initial-layout-helper {
            position: absolute; /* text-wrapper と同じ位置に配置 */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            visibility: hidden; /* 見えないがレイアウトには参加 */
            white-space: pre-wrap; /* 連続する空白と改行を保持 */
            line-height: inherit; /* 親から継承 */
            letter-spacing: inherit; /* 親から継承 */
            font-size: inherit; /* 親から継承 */
            text-align: inherit; /* 親から継承 */
        }
        #initial-layout-helper span {
            display: inline-block; /* 各文字をインラインブロックとして配置 */
            white-space: pre; /* 個々の文字の空白を保持 */
            /* span自体のフォントスタイルは親から継承される */
        }
        #initial-layout-helper br {
            display: block; /* brタグはブロック要素 */
        }


        /* アニメーション用の文字要素のベーススタイル */
        .animated-char {
            display: inline-block; /* 基本はインラインブロック */
            position: absolute; /* JSで位置確定後にabsoluteにする */
            opacity: 1;
            transform: translate(0, 0) rotate(0deg); /* 初期状態 */
            z-index: 2; /* 崩れる文字が手前になるように */
            will-change: transform, opacity; /* アニメーションのパフォーマンス最適化 */
            /* フォントスタイルは text-wrapper から継承 */
        }
        
        /* 崩れ落ちる文字 */
        .falling-char {
            animation-timing-function: cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }

        /* その場に残る文字 (Storyteller以外の**文字、<br>を含む) */
        .fixed-char {
            z-index: 3; /* 崩れる文字より手前 */
        }

        @keyframes fall-from-center {
            0% {
                opacity: 1;
                transform: translate(0, 0) rotate(0deg);
            }
            100% {
                opacity: 0;
                transform: translate(var(--randX, 0px), var(--randY, 0px)) rotate(var(--randRot, 0deg));
            }
        }

        .remaining-text-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Storyteller', cursive;
            font-size: 0;
            color: #000000;
            white-space: nowrap;
            z-index: 5;
            opacity: 0;
            pointer-events: none;
        }

        .remaining-char {
            display: inline-block;
            opacity: 1;
            transform: translate(0, 0) scale(1) rotate(0deg);
            position: relative; /* その場に残るためrelative */
            font-size: 10px; /* 崩れる文字と同じ初期サイズ */
            z-index: 4;
            will-change: transform, opacity, font-size;
        }

        @keyframes assembleAndGrow {
            0% {
                opacity: 0;
                transform: translate(var(--x), var(--y)) scale(0) rotate(var(--rot));
            }
            1% {
                opacity: 1;
            }
            100% {
                opacity: 1;
                transform: translate(0, 0) scale(1) rotate(0deg);
                font-size: min(80px, 6vw);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="text-wrapper" id="animatedText">
            </div>
        <div class="remaining-text-container" id="remainingText">
            </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const animatedTextElement = document.getElementById('animatedText');
            const remainingTextContainer = document.getElementById('remainingText');

            // ユーザーがHTMLに記述した元の文章を取得（ここでは仮の文字列を使用）
            // 実際のコンテンツはここに入力してください。
            // **Storyteller** のように**で囲むと崩れません。
            const initialRawTextContent = `FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK **Storyteller** / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR
FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK **Storyteller** / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR
FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK **Storyteller** / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR`; // ここに実際に表示したい文章を貼り付けてください

            const targetWord = "Storyteller";
            let initialCharPositions = []; // 各文字の初期位置情報を格納
            let fixedCharDataForStoryteller = []; // Storytellerの文字情報のみを格納

            // STEP 0: text-wrapperが初期状態でブラウザの中央に配置されることを保証
            // CSSで position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); は既に設定済み

            // STEP 1: 初期レイアウト計算用のヘルパー要素を text-wrapper 内に一時的に配置
            const layoutHelper = document.createElement('div');
            layoutHelper.id = 'initial-layout-helper';
            // text-wrapperに子要素を追加する前に、text-wrapperのスタイルが適用されていることを確認
            // animatedTextElement.appendChild(layoutHelper); // これを早くしすぎるとtext-wrapperのRectが不安定になる可能性

            // ダミー要素を介して、ユーザーが記述したテキストをHTML要素に変換
            const dummyDiv = document.createElement('div');
            // innerHTMLを使うと、改行が<br>に変換される
            // または、テキストノードと<br>要素を明示的に処理する
            const lines = initialRawTextContent.split('\n');
            lines.forEach((line, lineIndex) => {
                const nonCollapsiblePattern = /\*\*(.*?)\*\*/g;
                let lastIndex = 0;
                let match;

                while ((match = nonCollapsiblePattern.exec(line)) !== null) {
                    // 崩れる部分
                    for (let i = lastIndex; i < match.index; i++) {
                        const char = line[i];
                        const span = document.createElement('span');
                        span.textContent = char === ' ' ? '\u00A0' : char; // &nbsp;のUnicodeエスケープ
                        layoutHelper.appendChild(span);
                    }
                    // 崩れない部分
                    for (let i = 0; i < match[1].length; i++) {
                        const char = match[1][i];
                        const span = document.createElement('span');
                        span.textContent = char === ' ' ? '\u00A0' : char;
                        span.classList.add('non-collapsible-temp'); // 一時的にマーク
                        layoutHelper.appendChild(span);
                    }
                    lastIndex = nonCollapsiblePattern.lastIndex;
                }
                // 残りの崩れる部分
                for (let i = lastIndex; i < line.length; i++) {
                    const char = line[i];
                    const span = document.createElement('span');
                    span.textContent = char === ' ' ? '\u00A0' : char;
                    layoutHelper.appendChild(span);
                }

                if (lineIndex < lines.length - 1) { // 最後の行以外は改行を追加
                    layoutHelper.appendChild(document.createElement('br'));
                }
            });

            // レイアウトヘルパーをtext-wrapperに追加
            animatedTextElement.appendChild(layoutHelper);


            // STEP 2: ブラウザが初期レイアウトを完了するのを待つ (文字のずれ防止の核心部分)
            // rAFを二重にすることで、DOM変更→レンダリング→レイアウト計算の完了を待つ
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    // ここで layoutHelper の子要素から正確な位置情報を取得
                    const layoutChildren = layoutHelper.querySelectorAll('span, br');
                    const textWrapperRect = animatedTextElement.getBoundingClientRect(); // text-wrapper自体の絶対位置

                    layoutChildren.forEach(node => {
                        const rect = node.getBoundingClientRect();
                        const isBr = node.tagName.toLowerCase() === 'br';
                        const isNonCollapsible = node.classList ? node.classList.contains('non-collapsible-temp') : false;

                        initialCharPositions.push({
                            content: isBr ? '<br>' : (node.textContent === '\u00A0' ? '\u00A0' : node.textContent), // &nbsp;はUnicodeに変換
                            textContent: node.textContent, // 純粋なテキスト
                            isNonCollapsible: isNonCollapsible,
                            isBr: isBr,
                            left: rect.left - textWrapperRect.left, // text-wrapperを基準とした相対位置
                            top: rect.top - textWrapperRect.top,
                            width: rect.width,
                            height: rect.height
                        });
                    });

                    // レイアウトヘルパーをDOMから削除
                    animatedTextElement.removeChild(layoutHelper);

                    let currentTargetWordIndex = 0; // Storytellerの文字を順に取得するためのインデックス

                    // STEP 3: 取得した位置情報を使って、アニメーション用の文字を absolute 配置に再生成
                    initialCharPositions.forEach((data) => {
                        const span = document.createElement('span');
                        span.classList.add('animated-char');
                        
                        // <br>タグの場合はHTMLとして挿入、それ以外はtextContent
                        span.innerHTML = data.content === '<br>' ? '<br>' : (data.content === '\u00A0' ? '&nbsp;' : data.content);

                        // 正確な位置に配置
                        span.style.left = `${data.left}px`;
                        span.style.top = `${data.top}px`;
                        span.style.width = `${data.width}px`; // 幅も設定
                        span.style.height = `${data.height}px`; // 高さも設定

                        // fixed-char と falling-char の分類
                        if (data.isBr || data.isNonCollapsible || (data.textContent.trim().length > 0 && currentTargetWordIndex < targetWord.length && data.textContent.toLowerCase() === targetWord[currentTargetWordIndex].toLowerCase())) {
                            span.classList.add('fixed-char');
                            
                            // Storytellerの文字のみを fixedCharDataForStoryteller に格納
                            // **で囲まれていないStorytellerの文字、または**で囲まれたStorytellerの文字
                            if ((!data.isNonCollapsible && data.textContent.trim().length > 0 && currentTargetWordIndex < targetWord.length && data.textContent.toLowerCase() === targetWord[currentTargetWordIndex].toLowerCase()) ||
                                (data.isNonCollapsible && data.textContent.toLowerCase() === targetWord[currentTargetWordIndex].toLowerCase())) {
                                
                                fixedCharDataForStoryteller.push({
                                    originalElement: span, // 生成したspan要素自体を保持
                                    char: data.textContent,
                                    initialRect: data // 初期位置情報も保持
                                });
                                currentTargetWordIndex++;
                            }
                        } else {
                            span.classList.add('falling-char');
                        }
                        animatedTextElement.appendChild(span);
                    });

                    // アニメーションの開始ロジック
                    const startDelay = 3000; // 3秒 = 3000ミリ秒
                    const perCharFallDelay = 0.005;
                    const fallAnimationDuration = 2;
                    const assembleAndGrowDuration = 1.5;

                    setTimeout(() => {
                        const fallingChars = document.querySelectorAll('.falling-char');
                        fallingChars.forEach((charElement, charIndex) => {
                            const randX = (Math.random() - 0.5) * window.innerWidth * 2;
                            const randY = Math.random() * window.innerHeight * 2;
                            const randRot = Math.random() * 1080 - 540;
                            charElement.style.setProperty('--randX', `${randX}px`);
                            charElement.style.setProperty('--randY', `${randY}px`);
                            charElement.style.setProperty('--randRot', `${randRot}deg`);

                            charElement.style.animation = `fall-from-center ${fallAnimationDuration}s forwards`;
                            charElement.style.animationDelay = `${perCharFallDelay * charIndex}s`;
                        });

                        // 最も遅い落下アニメーションの終了時間を計算
                        const longestFallingAnimationEndTime = (fallingChars.length > 0 ? perCharFallDelay * (fallingChars.length - 1) : 0) * 1000 + fallAnimationDuration * 1000;

                        setTimeout(() => {
                            animatedTextElement.style.opacity = '0'; // 崩れた文章をフェードアウト
                            
                            // Storytellerの文字を集めるアニメーションを開始
                            fixedCharDataForStoryteller.forEach((data, index) => {
                                // ここで新しい.remaining-char要素を生成
                                const span = document.createElement('span');
                                span.classList.add('remaining-char');
                                span.textContent = data.char;

                                // remainingTextContainerの中心からの相対位置に変換
                                const remainingTextContainerRect = remainingTextContainer.getBoundingClientRect();
                                const relativeX = (data.initialRect.left + data.initialRect.width / 2) - (remainingTextContainerRect.left + remainingTextContainerRect.width / 2);
                                const relativeY = (data.initialRect.top + data.initialRect.height / 2) - (remainingTextContainerRect.top + remainingTextContainerRect.height / 2);

                                span.style.setProperty('--x', `${relativeX}px`);
                                span.style.setProperty('--y', `${relativeY}px`);
                                span.style.setProperty('--rot', `${Math.random() * 180 - 90}deg`);

                                span.style.opacity = '0'; // 初期は透明
                                span.style.transform = `translate(${relativeX}px, ${relativeY}px) scale(0) rotate(${Math.random() * 180 - 90}deg)`;

                                span.style.animation = `assembleAndGrow ${assembleAndGrowDuration}s forwards cubic-bezier(0.25, 0.1, 0.25, 1)`;
                                span.style.animationDelay = `${index * 0.1}s`;

                                remainingTextContainer.appendChild(span);

                                // 元のfixed-char要素はanimatedTextElementのopacity:0で非表示になる
                            });
                            remainingTextContainer.classList.add('show');

                        }, longestFallingAnimationEndTime);
                    }, startDelay);
                });
            });
        });
    </script>
</body>
</html>
