<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Text Animation</title>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;500&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #E81F27;
            font-family: 'Oswald', sans-serif;
            color: black; /* 文字色を黒に設定 */
            margin: 0;
            overflow: hidden; /* 崩れる文字がはみ出さないように */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            position: relative;
        }

        #initial-text-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%; /* テキストが収まるように調整 */
            text-align: center;
            line-height: 1.2;
            font-size: 2.5vw; /* 画面サイズに合わせて調整 */
            user-select: none; /* 文字選択を防止 */
            z-index: 10;
            opacity: 1;
        }

        .char-wrapper {
            display: inline-block;
            position: relative;
            white-space: pre; /* 空白が連続してもそのまま表示されるように */
        }

        .falling-char {
            position: absolute;
            left: 0;
            top: 0;
            transform: translate(0, 0);
            opacity: 1;
            transition: opacity 0.5s ease-out; /* フェードアウト用 */
            pointer-events: none; /* クリック不可に */
            user-select: none;
            color: black; /* 崩れる文字の色も黒に */
        }

        /* remaining-charはfinal-storyteller内のspanに適用 */
        .remaining-char {
            display: inline-block; /* flex itemとして機能させるため */
            transform: scale(1); /* 初期スケール */
            opacity: 1;
            font-size: inherit; /* 親からフォントサイズを継承 */
            white-space: pre; /* 空白が連続してもそのまま表示されるように */
            color: black; /* 残る文字の色も黒に */
        }

        #pile-container {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100px; /* 積もる領域の目安 */
            overflow: hidden;
            z-index: 5;
            pointer-events: none;
        }

        .piled-char {
            position: absolute;
            color: black; /* 積もった文字の色も黒に */
            opacity: 1;
            transition: opacity 2s ease-out; /* 積もった文字のフェードアウト */
            pointer-events: none;
            user-select: none;
        }

        #final-storyteller {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1);
            white-space: nowrap;
            opacity: 0; /* 最初は非表示 */
            z-index: 20;
            pointer-events: none;
            display: flex; /* 文字を横に並べるためにflexboxを使用 */
            justify-content: center;
            align-items: center;
            font-size: 2.5vw; /* 初期サイズは他の文字に合わせる */
            /* アニメーションプロパティ */
            transition: transform 2s ease-in-out, letter-spacing 2s ease-in-out;
        }

        /* 拡大と文字間隔調整のためのクラス */
        #final-storyteller.animate-final {
            transform: translate(-50%, -50%) scale(3);
            letter-spacing: 0.15em; /* 拡大に合わせて文字間隔を調整 */
            /* 必要であれば、さらに文字全体の幅を考慮した調整も可能 */
            /* padding: 0 calc(2.5vw * 10 * 3 * 0.15 / 2); /* 仮の調整 */
        }
    </style>
</head>
<body>
    <div id="initial-text-container"></div>
    <div id="pile-container"></div>
    <div id="final-storyteller"></div>

    <script>
        const initialText = `FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR
FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR
FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR`;

        const initialTextContainer = document.getElementById('initial-text-container');
        const pileContainer = document.getElementById('pile-container');
        const finalStoryteller = document.getElementById('final-storyteller');

        const targetChars = ['s', 't', 'o', 'r', 'y', 't', 'e', 'l', 'l', 'e', 'r'];
        let charElements = [];
        let remainingCharIndices = [];
        let completedFallingChars = 0;
        let totalFallingChars = 0;

        // 文字をspanでラップしてDOMに追加
        function setupInitialText() {
            let tempHTML = '';
            for (let i = 0; i < initialText.length; i++) {
                const char = initialText[i];
                if (char === ' ' || char === '\n') {
                    tempHTML += `<span class="char-wrapper" data-char="${char}">`;
                    tempHTML += (char === ' ') ? '&nbsp;' : '<br>';
                    tempHTML += '</span>';
                } else {
                    tempHTML += `<span class="char-wrapper" data-char="${char}">${char}</span>`;
                }
            }
            initialTextContainer.innerHTML = tempHTML;
            charElements = Array.from(initialTextContainer.querySelectorAll('.char-wrapper'));

            // 残す文字のインデックスを決定（バラけた場所で）
            let tempRemainingIndices = [];
            let lastUsedIndex = -1; // 最後に選択されたインデックスを記録

            targetChars.forEach(targetChar => {
                let availableIndices = [];
                // ターゲット文字と一致し、かつまだ選ばれていない文字を探す
                for (let i = 0; i < charElements.length; i++) {
                    if (!tempRemainingIndices.includes(i) && charElements[i].dataset.char.toLowerCase() === targetChar) {
                        availableIndices.push(i);
                    }
                }

                if (availableIndices.length > 0) {
                    // 既に選ばれたインデックスと最も距離があるものを優先
                    let bestIndex = -1;
                    let maxMinDistance = -1;

                    for (const currentIdx of availableIndices) {
                        if (tempRemainingIndices.length === 0) {
                            // 最初の文字の場合、どこでも良いのでとりあえず選ぶ
                            bestIndex = currentIdx;
                            break;
                        } else {
                            let minDistance = Infinity;
                            for (const selectedIdx of tempRemainingIndices) {
                                minDistance = Math.min(minDistance, Math.abs(currentIdx - selectedIdx));
                            }
                            if (minDistance > maxMinDistance) {
                                maxMinDistance = minDistance;
                                bestIndex = currentIdx;
                            }
                        }
                    }
                    if (bestIndex !== -1) {
                        tempRemainingIndices.push(bestIndex);
                    } else {
                        console.warn(`Target character '${targetChar}' could not be placed non-continuously.`);
                    }
                } else {
                    console.warn(`Target character '${targetChar}' not found in text.`);
                }
            });
            remainingCharIndices = tempRemainingIndices;

            // 最終的に表示されるstorytellerの文字を作成
            finalStoryteller.innerHTML = targetChars.map(char => `<span class="remaining-char">${char}</span>`).join('');
            finalStoryteller.style.opacity = 0; // 初期は非表示
        }


        // 文字を崩すアニメーション
        function startFallingAnimation() {
            charElements.forEach((charElement, index) => {
                if (!remainingCharIndices.includes(index)) {
                    totalFallingChars++; // 崩れる文字の総数をカウント
                }
            });

            charElements.forEach((charElement, index) => {
                const char = charElement.dataset.char;

                // 残す文字のインデックスに含まれていない場合は崩す
                if (!remainingCharIndices.includes(index)) {
                    const rect = charElement.getBoundingClientRect();
                    const initialX = rect.left + window.scrollX;
                    const initialY = rect.top + window.scrollY;
                    const fontSize = parseFloat(window.getComputedStyle(charElement).fontSize);

                    // 崩れる文字の要素を新しく作成
                    const fallingCharDiv = document.createElement('div');
                    fallingCharDiv.classList.add('falling-char');
                    fallingCharDiv.textContent = char === '\n' ? '' : char; // 改行文字は表示しない
                    fallingCharDiv.style.cssText = `
                        position: fixed; /* 画面固定で動かす */
                        left: ${initialX}px;
                        top: ${initialY}px;
                        font-size: ${fontSize}px;
                        pointer-events: none;
                        user-select: none;
                        z-index: 10;
                    `;
                    document.body.appendChild(fallingCharDiv);

                    // 初期テキストの文字は非表示に
                    charElement.style.opacity = 0;

                    // アニメーション開始
                    const duration = Math.random() * 0.5 + 0.8; // 0.8秒から1.3秒
                    const delay = Math.random() * 0.2; // 少しランダムな遅延
                    const targetY = window.innerHeight - (Math.random() * 50 + 20); // 画面下部に積もるように
                    const targetX = Math.random() * (window.innerWidth - fontSize * 2) + fontSize; // ランダムなX位置

                    fallingCharDiv.animate([
                        { transform: 'translate(0, 0)', opacity: 1 },
                        { transform: `translate(${targetX - initialX}px, ${targetY - initialY}px)`, opacity: 1 }
                    ], {
                        duration: duration * 1000,
                        delay: delay * 1000,
                        easing: 'ease-in',
                        fill: 'forwards'
                    }).onfinish = () => {
                        // アニメーション終了後、積もる文字として配置
                        const piledChar = document.createElement('div');
                        piledChar.classList.add('piled-char');
                        piledChar.textContent = char === '\n' ? '' : char;
                        piledChar.style.cssText = `
                            left: ${targetX}px;
                            top: ${targetY}px;
                            font-size: ${fontSize}px;
                        `;
                        pileContainer.appendChild(piledChar);
                        fallingCharDiv.remove(); // 崩れる文字は削除

                        completedFallingChars++;
                        if (completedFallingChars === totalFallingChars) {
                            // 全ての文字が積もり終わったらフェードアウトとstorytellerアニメーションを開始
                            startPileFadeOutAndStorytellerAnimation();
                        }
                    };
                } else {
                    // 残る文字は元の位置に残し、色を黒に設定
                    charElement.style.color = 'black';
                }
            });
            initialTextContainer.style.opacity = 0; // 全体が消えるように
        }

        function startPileFadeOutAndStorytellerAnimation() {
            // 積もった文字をフェードアウト
            const piledChars = document.querySelectorAll('.piled-char');
            piledChars.forEach(char => {
                char.style.opacity = 0; // CSS transitionで2秒かけてフェードアウト
            });

            // "storyteller" を中央に配置し、拡大アニメーション
            finalStoryteller.style.opacity = 1;

            // アニメーションを適用
            // transitionプロパティを使用するため、クラスを追加するだけでOK
            setTimeout(() => {
                finalStoryteller.classList.add('animate-final');
            }, 50); // クラス追加を少し遅らせてtransitionを有効にする
        }

        // 初期化処理
        document.addEventListener('DOMContentLoaded', () => {
            setupInitialText();

            // 3秒後にアニメーション開始
            setTimeout(() => {
                startFallingAnimation();
            }, 3000);
        });
    </script>
</body>
</html>
