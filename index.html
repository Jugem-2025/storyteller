<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Text Animation</title>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;500&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #E81F27;
            font-family: 'Oswald', sans-serif;
            color: black; /* 文字色を黒に設定 */
            margin: 0;
            overflow: hidden; /* 崩れる文字がはみ出さないように */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            position: relative;
        }

        #initial-text-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%; /* テキストが収まるように調整 */
            text-align: center;
            line-height: 1.2;
            font-size: 3vw; /* 文字サイズを3vwに設定 */
            user-select: none; /* 文字選択を防止 */
            z-index: 10;
            opacity: 1;
        }

        .char-wrapper {
            display: inline-block;
            position: relative;
            white-space: pre; /* 空白が連続してもそのまま表示されるように */
        }

        .falling-char {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 1;
            /* transition: opacity 0.5s ease-out; /* Falling animation handles opacity */ */
            pointer-events: none; /* クリック不可に */
            user-select: none;
            color: black; /* 崩れる文字の色も黒に */
        }

        /* remaining-charはfinal-storyteller内のspanに適用 */
        .remaining-char {
            display: inline-block; /* flex itemとして機能させるため */
            transform: scale(1); /* 初期スケール */
            opacity: 1;
            font-size: inherit; /* 親からフォントサイズを継承 */
            white-space: pre; /* 空白が連続してもそのまま表示されるように */
            color: black; /* 残る文字の色も黒に設定（変更なし） */
        }

        #pile-container {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100px; /* 積もる領域の目安 */
            overflow: hidden;
            z-index: 5;
            pointer-events: none;
        }

        .piled-char {
            position: absolute;
            color: black; /* 積もった文字の色も黒に */
            opacity: 1;
            transition: opacity 2s ease-out; /* 積もった文字のフェードアウト */
            pointer-events: none;
            user-select: none;
        }

        #final-storyteller {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1);
            white-space: nowrap;
            opacity: 0; /* 最初は非表示 */
            z-index: 20;
            pointer-events: none;
            display: flex; /* 文字を横に並べるためにflexboxを使用 */
            justify-content: center;
            align-items: center;
            font-size: 3vw; /* 初期サイズは他の文字に合わせる */
            /* アニメーションプロパティ */
            transition: transform 2s ease-in-out, letter-spacing 2s ease-in-out, opacity 0.5s ease-out; /* opacityもtransition対象に */
        }

        /* 拡大と文字間隔調整のためのクラス */
        #final-storyteller.animate-final {
            transform: translate(-50%, -50%) scale(3);
            letter-spacing: 0.15em; /* 拡大に合わせて文字間隔を調整 */
            opacity: 1; /* アニメーション開始で表示 */
        }
    </style>
</head>
<body>
    <div id="initial-text-container"></div>
    <div id="pile-container"></div>
    <div id="final-storyteller"></div>

    <script>
        const initialText = `FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR
FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR
FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR`;

        const initialTextContainer = document.getElementById('initial-text-container');
        const pileContainer = document.getElementById('pile-container');
        const finalStoryteller = document.getElementById('final-storyteller');

        // 残す文字を小文字に統一
        const targetChars = ['s', 't', 'o', 'r', 'y', 't', 'e', 'l', 'l', 'e', 'r'];
        let charElements = [];
        let remainingCharIndices = []; // 残る文字の元のDOM上のインデックス
        let completedFallingChars = 0;
        let totalFallingChars = 0;

        // 文字をspanでラップしてDOMに追加
        function setupInitialText() {
            let tempHTML = '';
            for (let i = 0; i < initialText.length; i++) {
                const char = initialText[i];
                if (char === ' ' || char === '\n') {
                    tempHTML += `<span class="char-wrapper" data-char="${char}" data-index="${i}">`;
                    tempHTML += (char === ' ') ? '&nbsp;' : '<br>';
                    tempHTML += '</span>';
                } else {
                    tempHTML += `<span class="char-wrapper" data-char="${char}" data-index="${i}">${char}</span>`;
                }
            }
            initialTextContainer.innerHTML = tempHTML;
            charElements = Array.from(initialTextContainer.querySelectorAll('.char-wrapper'));

            // 残す文字のインデックスを決定（バラけた場所で）
            let selectedIndices = new Set(); // 最終的に選ばれたインデックスを管理
            
            // 各targetCharに対応する利用可能なインデックスを事前に収集
            let availableIndicesForTarget = new Array(targetChars.length).fill(0).map(() => []);
            for (let i = 0; i < charElements.length; i++) {
                const charFromDOM = charElements[i].dataset.char.toLowerCase(); // DOMの文字を小文字に変換
                for (let j = 0; j < targetChars.length; j++) {
                    if (charFromDOM === targetChars[j]) {
                        availableIndicesForTarget[j].push(i);
                    }
                }
            }

            // 選定ロジックを改善: ターゲット文字ごとに利用可能な候補をシャッフルし、距離を考慮して選ぶ
            for (let i = 0; i < targetChars.length; i++) {
                const currentTargetChar = targetChars[i];
                let bestIndex = -1;
                let maxMinDistance = -1;
                
                // 現在のターゲット文字の候補をシャッフル
                let shuffledCandidates = [...availableIndicesForTarget[i]];
                for (let k = shuffledCandidates.length - 1; k > 0; k--) {
                    const j = Math.floor(Math.random() * (k + 1));
                    [shuffledCandidates[k], shuffledCandidates[j]] = [shuffledCandidates[j], shuffledCandidates[k]];
                }

                // 候補の中から、既に選択されたインデックスと重複せず、かつ距離が離れているものを探す
                for (const currentIdx of shuffledCandidates) {
                    if (selectedIndices.has(currentIdx)) {
                        continue; // 既に選ばれている場合はスキップ
                    }

                    if (selectedIndices.size === 0) {
                        bestIndex = currentIdx;
                        break;
                    }

                    let minDistance = Infinity;
                    selectedIndices.forEach(selectedIdx => {
                        minDistance = Math.min(minDistance, Math.abs(currentIdx - selectedIdx));
                    });

                    if (minDistance > maxMinDistance) {
                        maxMinDistance = minDistance;
                        bestIndex = currentIdx;
                    }
                }

                if (bestIndex !== -1) {
                    remainingCharIndices.push(bestIndex);
                    selectedIndices.add(bestIndex);
                } else {
                    console.warn(`Warning: Could not find a suitable non-consecutive character for '${currentTargetChar}'.`);
                    // 見つからない場合は、残す文字の要件を満たせない可能性があるが、処理は続行
                }
            }
            
            // 最終的に表示されるstorytellerの文字を作成
            finalStoryteller.innerHTML = targetChars.map(char => `<span class="remaining-char">${char}</span>`).join('');
            finalStoryteller.style.opacity = 0; // 初期は非表示
        }


        // 文字を崩すアニメーション
        function startFallingAnimation() {
            totalFallingChars = charElements.length - remainingCharIndices.length;
            if (totalFallingChars < 0) totalFallingChars = 0;

            let processedChars = new Set(remainingCharIndices); // 残す文字は最初からprocessedとする
            let animationQueue = [];

            // 崩壊の起点となる文字（画面中央上部の1点から複数の文字がほぼ同時に落ち始め）
            // 中心点の文字を見つける
            let centerCharIndex = -1;
            let minDistanceToCenter = Infinity;
            const screenCenterX = window.innerWidth / 2;
            const screenCenterYUpper = window.innerHeight / 4; // 画面上部1/4あたり

            for(let i = 0; i < charElements.length; i++) {
                if (processedChars.has(i)) continue; // 既に処理済み（残す文字も含む）は除外

                const charRect = charElements[i].getBoundingClientRect();
                const charCenterX = charRect.left + charRect.width / 2;
                const charCenterY = charRect.top + charRect.height / 2;

                const dist = Math.sqrt(
                    Math.pow(charCenterX - screenCenterX, 2) +
                    Math.pow(charCenterY - screenCenterYUpper, 2)
                );

                if (dist < minDistanceToCenter) {
                    minDistanceToCenter = dist;
                    centerCharIndex = i;
                }
            }

            if (centerCharIndex !== -1) {
                // 中心点となる文字をキューに追加
                animationQueue.push({ index: centerCharIndex, delay: 0 });
                processedChars.add(centerCharIndex);

                // 中心点から近い周囲の文字を初期崩壊の候補として追加
                const initialSpreadRadius = 150; // 中心から同時に落ち始める範囲
                for (let i = 0; i < charElements.length; i++) {
                    if (processedChars.has(i)) continue; // 既に処理済み（残す文字も含む）は除外

                    const charRect = charElements[i].getBoundingClientRect();
                    const centerCharRect = charElements[centerCharIndex].getBoundingClientRect();
                    const dist = Math.sqrt(
                        Math.pow((centerCharRect.left + centerCharRect.width / 2) - (charRect.left + charRect.width / 2), 2) +
                        Math.pow((centerCharRect.top + centerCharRect.height / 2) - (charRect.top + charRect.height / 2), 2)
                    );

                    if (dist < initialSpreadRadius) {
                        animationQueue.push({ index: i, delay: Math.random() * 150 }); // ほぼ同時に落ち始めるための僅かなランダム遅延
                        processedChars.add(i);
                    }
                }
            }
            
            // 落ちる文字が一つもない場合 (残す文字のみの場合など) は、アニメーションをスキップして次へ
            if (animationQueue.length === 0 && totalFallingChars === 0) {
                startPileFadeOutAndStorytellerAnimation();
                return;
            }

            let head = 0;
            // 広がりを調整するためのパラメータ (表示から8秒〜10秒)
            // 崩壊開始が3秒後なので、アニメーション自体は5秒〜7秒で完了させる
            const maxSpreadDelay = 6500; // 崩壊の伝播が完了するまでの時間 (6.5秒に設定すると、全体で3+6.5=9.5秒となり8〜10秒に収まる)
            const baseSpreadRadius = 100; // 広がりの初期半径を少し大きくして、波紋のように広がりやすく
            const spreadFactor = 0.15; // 伝播の遅延の計算に使う係数をさらに小さくして、伝播を速くし連鎖を強調

            while (head < animationQueue.length) {
                const { index: currentIdx, delay: baseDelay } = animationQueue[head++];
                
                const charElement = charElements[currentIdx];
                // ここでは processedChars.has(currentIdx) のチェックは不要。
                // キューに入れる時点でprocessedCharsに追加されているため。
                // ただし、念のため remainingCharIndices に含まれないことを確認しておく。
                if (remainingCharIndices.includes(currentIdx)) {
                    // このブロックは通常実行されないはずだが、残す文字が誤ってキューに入った場合の安全策
                    continue; 
                }

                const char = charElement.dataset.char;
                const rect = charElement.getBoundingClientRect();
                const initialX = rect.left + window.scrollX;
                const initialY = rect.top + window.scrollY;
                const fontSize = parseFloat(window.getComputedStyle(charElement).fontSize);

                const fallingCharDiv = document.createElement('div');
                fallingCharDiv.classList.add('falling-char');
                fallingCharDiv.textContent = char === '\n' ? '' : char;
                fallingCharDiv.style.cssText = `
                    position: fixed;
                    left: ${initialX}px;
                    top: ${initialY}px;
                    font-size: ${fontSize}px;
                    pointer-events: none;
                    user-select: none;
                    z-index: 10;
                `;
                document.body.appendChild(fallingCharDiv);

                // 崩れる文字の元のchar-wrapper要素のみ非表示にする
                charElement.style.opacity = 0; 

                // 浮遊感、ゆっくり落ちる、ランダムな回転と左右の揺れ
                const fallDuration = Math.random() * 1.5 + 2.5; // 2.5秒から4秒で落ちる (長くして浮遊感)
                const targetY = window.innerHeight - (Math.random() * 80 + 20); // 積もる位置を調整
                const targetX = initialX + (Math.random() - 0.5) * 200; // 左右の揺れ幅を少し大きく
                const rotateDegree = (Math.random() - 0.5) * 360; // ランダムな回転

                fallingCharDiv.animate([
                    { transform: 'translate(0, 0) rotate(0deg)', opacity: 1 },
                    { transform: `translate(${targetX - initialX}px, ${targetY - initialY}px) rotate(${rotateDegree}deg)`, opacity: 1 }
                ], {
                    duration: fallDuration * 1000,
                    delay: baseDelay, // 個々の文字の開始遅延は伝播の遅延に任せる
                    easing: 'ease-out', // ゆっくり落ちていく感じを強調
                    fill: 'forwards'
                }).onfinish = () => {
                    const piledChar = document.createElement('div');
                    piledChar.classList.add('piled-char');
                    piledChar.textContent = char === '\n' ? '' : char;
                    piledChar.style.cssText = `
                        left: ${targetX}px;
                        top: ${targetY}px;
                        font-size: ${fontSize}px;
                    `;
                    pileContainer.appendChild(piledChar);
                    fallingCharDiv.remove();

                    completedFallingChars++;
                    if (completedFallingChars === totalFallingChars) {
                        startPileFadeOutAndStorytellerAnimation();
                    }
                };

                // 周囲の文字をキューに追加（崩壊の伝播）
                for (let i = 0; i < charElements.length; i++) {
                    if (processedChars.has(i)) continue; // 既に処理済み（残す文字も含む）は除外

                    const charRect = charElements[i].getBoundingClientRect();
                    const currentElementRect = charElement.getBoundingClientRect(); // 伝播元となる文字のRect
                    const dist = Math.sqrt(
                        Math.pow((currentElementRect.left + currentElementRect.width / 2) - (charRect.left + charRect.width / 2), 2) +
                        Math.pow((currentElementRect.top + currentElementRect.height / 2) - (charRect.top + charRect.height / 2), 2)
                    );

                    // 距離と確率に基づいて伝播を調整 (波紋のように広がる、ドミノ倒し感を強化)
                    const currentSpreadRadius = baseSpreadRadius * (1 + (baseDelay / maxSpreadDelay) * 0.7); // 遅延に応じて広がる範囲を大きく
                    const probability = dist < currentSpreadRadius ? (1 - (dist / currentSpreadRadius)) : 0; // 距離が近いほど高確率
                    
                    if (Math.random() < probability * 2.5) { // 確率をさらに上げて、確実に伝播させる
                        const nextDelay = baseDelay + (dist * spreadFactor) + (Math.random() * 30); // 距離とわずかなランダム遅延
                        if (nextDelay < maxSpreadDelay) {
                            animationQueue.push({ index: i, delay: nextDelay });
                            processedChars.add(i);
                        }
                    }
                }
            }
        }

        function startPileFadeOutAndStorytellerAnimation() {
            // 積もった文字をフェードアウト
            const piledChars = document.querySelectorAll('.piled-char');
            piledChars.forEach(char => {
                char.style.opacity = 0; // CSS transitionで2秒かけてフェードアウト
            });

            // 崩れ落ちなかった文字（storyteller）の表示と拡大を2秒後に開始
            setTimeout(() => {
                finalStoryteller.classList.add('animate-final'); // CSS transitionでアニメーション
            }, 2000); // フェードアウトの2秒後
        }

        // 初期化処理
        document.addEventListener('DOMContentLoaded', () => {
            setupInitialText();

            // 3秒後にアニメーション開始
            setTimeout(() => {
                startFallingAnimation();
            }, 3000);
        });
    </script>
</body>
</html>
