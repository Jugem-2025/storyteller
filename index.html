<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Text Effect</title>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #E81F27; /* 背景色 */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* 崩れた文字がはみ出さないように */
            font-family: 'Oswald Medium', sans-serif; /* フォント */
            color: black; /* 文字色 */
            perspective: 1000px; /* 3D効果のため */
        }

        .text-container {
            position: relative;
            text-align: center;
            line-height: 1.2; /* 行の高さを調整 */
        }

        .char-wrapper {
            display: inline-block;
            position: relative;
            white-space: pre; /* 半角スペースを保持 */
        }

        .char {
            display: inline-block;
            font-size: 3vw; /* 文字サイズ */
            opacity: 1;
            transform: translateZ(0); /* ハードウェアアクセラレーションを有効に */
            transition: transform 0.5s ease-out, opacity 0.5s ease-out, top 0.5s ease-out, left 0.5s ease-out; /* 残る文字の移動用 */
            will-change: transform, opacity, top, left; /* アニメーションのパフォーマンス改善 */
        }

        /* 崩れる文字のアニメーション */
        .char.fall {
            animation: fallAnimation 6s forwards; /* 6秒かけて崩れ落ちる */
            animation-timing-function: cubic-bezier(0.25, 0.46, 0.45, 0.94); /* 浮遊感のあるイージング */
        }

        @keyframes fallAnimation {
            0% {
                transform: translateY(0) rotateX(0deg) rotateY(0deg) rotateZ(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotateX(720deg) rotateY(720deg) rotateZ(720deg); /* 下方向に落ちて回転 */
                opacity: 0; /* 画面下部に積もるように見せるため透明に */
            }
        }

        /* 残る文字のスタイル */
        .char.remain {
            opacity: 1;
        }

        /* 残った文字の最終的なスタイル（storyteller） */
        .final-storyteller {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1);
            white-space: nowrap;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0; /* 最初は非表示 */
            transition: all 2s ease-in-out; /* ヌルッとした移動と拡大 */
            z-index: 10;
        }

        .final-storyteller.active {
            opacity: 1;
            transform: translate(-50%, -50%) scale(3); /* 3倍に拡大 */
            letter-spacing: 0.5em; /* 文字間隔を広げる */
        }
    </style>
</head>
<body>
    <div class="text-container" id="textContainer"></div>
    <div class="final-storyteller" id="finalStoryteller"></div>

    <script>
        const originalText = `FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR
FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR
FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR`;

        const textContainer = document.getElementById('textContainer');
        const finalStoryteller = document.getElementById('finalStoryteller');
        const chars = [];
        const targetRemainChars = ['s', 't', 'o', 'r', 'y', 't', 'e', 'l', 'l', 'e', 'r'];
        const remainingCharIndices = [];

        // テキストを分解し、span要素としてDOMに追加
        originalText.split('').forEach((char, index) => {
            const charWrapper = document.createElement('span');
            charWrapper.classList.add('char-wrapper');

            const charSpan = document.createElement('span');
            charSpan.classList.add('char');
            charSpan.textContent = char;

            charWrapper.appendChild(charSpan);
            textContainer.appendChild(charWrapper);
            chars.push({ wrapper: charWrapper, span: charSpan, originalChar: char });
        });

        // 残す文字のインデックスをランダムに選定
        function selectRemainingChars() {
            let availableIndices = [];
            for (let i = 0; i < chars.length; i++) {
                availableIndices.push(i);
            }

            // 'storyteller'の各文字について、元のテキストから適切なインデックスを探す
            targetRemainChars.forEach(targetChar => {
                let foundIndex = -1;
                // 利用可能なインデックスの中からランダムに選び、かつターゲット文字と一致するものを探す
                // 文中から広く文字を選ぶため、ランダム性を加える
                let shuffledIndices = availableIndices.sort(() => 0.5 - Math.random());
                for (let i = 0; i < shuffledIndices.length; i++) {
                    const idx = shuffledIndices[i];
                    if (chars[idx].originalChar.toLowerCase() === targetChar.toLowerCase() && !remainingCharIndices.includes(idx)) {
                        foundIndex = idx;
                        break;
                    }
                }
                if (foundIndex !== -1) {
                    remainingCharIndices.push(foundIndex);
                    // 選ばれたインデックスは利用可能なリストから削除
                    availableIndices = availableIndices.filter(item => item !== foundIndex);
                }
            });

            // 念のため、選ばれた文字が指定された文字数になっているか確認
            while (remainingCharIndices.length < targetRemainChars.length) {
                // 足りない場合は、まだ選ばれていない文字の中からランダムに追加
                let added = false;
                for (let i = 0; i < availableIndices.length; i++) {
                    const idx = availableIndices[i];
                    if (!remainingCharIndices.includes(idx)) {
                        remainingCharIndices.push(idx);
                        added = true;
                        break;
                    }
                }
                if (!added) break; // 全ての文字を選んだらループを抜ける
            }

            // 最終的に選ばれた文字を、targetRemainCharsの順序でソート（DOMでの表示順とは異なる）
            // これは残す文字のインデックスを決定するだけで、実際の表示順には影響しない
            // 実際の表示順は最後の集約アニメーションで制御
        }

        // ページ表示から3秒後に文字を崩し始める
        setTimeout(() => {
            selectRemainingChars(); // 残す文字のインデックスを決定

            const triggerPointX = window.innerWidth / 3; // 最上部の左から3分の1
            const triggerPointY = 0;

            chars.forEach((charObj, index) => {
                const charSpan = charObj.span;
                const rect = charSpan.getBoundingClientRect(); // 各文字の位置を取得

                if (!remainingCharIndices.includes(index)) {
                    // 崩れる文字
                    // 距離に基づいて遅延を計算し、波紋のように広がる効果を作成
                    const distance = Math.sqrt(Math.pow(rect.left - triggerPointX, 2) + Math.pow(rect.top - triggerPointY, 2));
                    const delay = (distance / (window.innerWidth / 2)) * 3; // 画面幅の半分までの距離に応じて最大3秒の遅延

                    charSpan.style.animationDelay = `${delay}s`;
                    charSpan.classList.add('fall');
                } else {
                    // 残る文字
                    charSpan.classList.add('remain');
                }
            });

            // 全体が6秒かけて崩れ落ちるアニメーションが終了した後、フェードアウトを開始
            setTimeout(() => {
                textContainer.style.transition = 'opacity 2s ease-out';
                textContainer.style.opacity = 0; // 全体がフェードアウト
            }, 3000 + 6000); // 表示から3秒 + 崩壊に6秒 = 9秒後にフェードアウト開始

            // フェードアウトが完了した後、残った文字を集約
            setTimeout(() => {
                textContainer.style.display = 'none'; // テキストコンテナを非表示にする

                // 残った文字のDOM要素を収集し、表示順（ターゲット文字の順）に並べ替える
                const sortedRemainingChars = [];
                targetRemainChars.forEach(targetChar => {
                    let foundChar = null;
                    for(let i = 0; i < remainingCharIndices.length; i++) {
                        const originalIndex = remainingCharIndices[i];
                        if (chars[originalIndex].originalChar.toLowerCase() === targetChar.toLowerCase() && !sortedRemainingChars.some(item => item.originalIndex === originalIndex)) {
                            foundChar = {
                                span: chars[originalIndex].span,
                                originalIndex: originalIndex // 元のインデックスも保持
                            };
                            break;
                        }
                    }
                    if (foundChar) {
                        sortedRemainingChars.push(foundChar);
                    }
                });

                // finalStorytellerに文字を追加
                sortedRemainingChars.forEach(charInfo => {
                    const charSpan = document.createElement('span');
                    charSpan.textContent = charInfo.span.textContent;
                    charSpan.classList.add('char'); // 基本的なスタイルを適用
                    charSpan.style.fontSize = '3vw'; // 初期サイズを設定
                    charInfo.span.style.opacity = 0; // 元の位置の文字を非表示にする
                    finalStoryteller.appendChild(charSpan);
                });


                finalStoryteller.classList.add('active'); // ヌルッと移動と拡大アニメーションを開始

            }, 3000 + 6000 + 2000); // 崩壊開始3秒 + 崩壊6秒 + フェードアウト2秒 = 11秒後に集約開始

        }, 3000); // ページ表示から3秒後に実行
    </script>
</body>
</html>
