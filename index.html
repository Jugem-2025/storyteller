<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Text Animation</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@500&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #E81F27; /* ① 背景の色 */
            font-family: 'Oswald', sans-serif; /* ② フォント */
            color: black; /* ② 文字の色 */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            position: relative;
        }

        #text-container {
            text-align: center;
            line-height: 1.2;
            word-break: break-all; /* 単語の途中で改行を許可 */
            font-size: 3vw; /* ② 文字のサイズ */
            position: relative;
            padding: 2vw; /* 文字が端に寄りすぎないようにパディング */
        }

        .char {
            display: inline-block;
            position: relative;
            opacity: 1;
            transform: translateY(0) rotate(0deg) translateX(0); /* 初期状態 */
            transition: opacity 0.5s, transform 0.5s; /* フェードアウト時に使用 */
            will-change: transform, opacity; /* アニメーションのパフォーマンス最適化 */
        }

        .char.falling {
            animation: fall 6s forwards; /* ④ 6秒かけて崩れ落ちる */
            animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1); /* ヌルっとした落下 */
        }

        /* 落下アニメーション（下方向、回転、左右の揺れを表現） */
        @keyframes fall {
            0% {
                opacity: 1;
                transform: translateY(0) rotate(0deg) translateX(0);
            }
            100% {
                opacity: 0; /* 崩れ落ちる途中で消えるように */
                /* 画面下部へ大きく移動させることで「積もる」前の状態を表現 */
                transform: translateY(150vh) rotate(var(--rotate-deg, 360deg)) translateX(var(--shake-x, 0px));
            }
        }

        /* 文字の積もりアニメーション後の状態（透明で画面下部に移動） */
        .char.stacked {
            opacity: 0;
            /* 画面下部に積もるようにするが、実際の物理的な積もりは表現せず、
               単に透明になって画面外に出ることで「消えた」状態とする */
            transform: translateY(100vh); /* 画面外へ */
        }

        /* 残った文字の最終的なコンテナ */
        #final-storyteller-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex; /* flexboxで中央揃え */
            justify-content: center;
            align-items: center;
            z-index: 100;
            white-space: nowrap; /* 文字列が改行しないように */
        }

        /* 残った文字の移動と拡大 */
        .char.storyteller-final {
            /* ⑤ 残る文字の色は黒のまま */
            color: black;
            opacity: 1; /* 必ず表示 */
            position: relative; /* flexアイテムとして機能させるため */
            transform: translate(0, 0) scale(1); /* 初期状態（relativeからの相対移動） */
            transition: all 2s ease-in-out; /* ⑧ ヌルっとした拡大と移動 */
            font-size: 3vw; /* 拡大前のサイズ */
            letter-spacing: normal; /* 拡大前の文字間隔 */
        }

        .char.storyteller-final.enlarged {
            font-size: 9vw; /* ⑧ 3倍の大きさ */
            /* 拡大と同時に文字間隔を広げ、縦横比を調整 */
            /* letter-spacingの調整はフォントや文字数に依存するため、この値は調整が必要です */
            /* 例: 0.15em は一例。's' 't' 'o' 'r' 'y' 't' 'e' 'l' 'l' 'e' 'r' で試しながら調整 */
            letter-spacing: 0.05em; /* 調整後の文字間隔 */
        }
    </style>
</head>
<body>
    <div id="text-container"></div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const textContainer = document.getElementById('text-container');
            const fullText = `FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR
FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR
FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR`; // ③ 初期表示文章

            const charsToKeep = ['s', 't', 'o', 'r', 'y', 't', 'e', 'l', 'l', 'e', 'r']; // ⑤ 残す文字
            let keptCharSpans = [];
            let currentKeptCharIndex = 0;

            // 各文字をspanでラップ
            fullText.split('').forEach((char, index) => {
                const charSpan = document.createElement('span');
                charSpan.textContent = char;
                charSpan.classList.add('char');

                // 残す文字を特定し、クラスを追加
                // 大文字小文字を区別せず、指定された順番で残す
                if (char.trim() !== '' && currentKeptCharIndex < charsToKeep.length && char.toLowerCase() === charsToKeep[currentKeptCharIndex]) {
                    charSpan.classList.add('keep-char');
                    charSpan.dataset.charIndex = currentKeptCharIndex; // 何番目の残す文字か記録
                    keptCharSpans.push(charSpan);
                    currentKeptCharIndex++;
                }
                textContainer.appendChild(charSpan);
            });

            const allChars = document.querySelectorAll('.char');

            // ④ 3秒後に文字が崩れ落ち始める
            setTimeout(() => {
                allChars.forEach((char) => {
                    if (!char.classList.contains('keep-char')) {
                        // ランダムな回転と左右の揺れを設定
                        const randomRotate = Math.random() * 720 - 360; // -360degから360deg
                        const randomShakeX = Math.random() * 60 - 30; // -30pxから30px

                        char.style.setProperty('--rotate-deg', `${randomRotate}deg`);
                        char.style.setProperty('--shake-x', `${randomShakeX}px`);

                        // 波紋のように広がる表現のため、中央からの距離に応じて落下開始を遅延
                        const textContainerRect = textContainer.getBoundingClientRect();
                        const charRect = char.getBoundingClientRect();
                        const charCenterX = charRect.left + charRect.width / 2;
                        const charCenterY = charRect.top + charRect.height / 2;
                        const containerCenterX = textContainerRect.left + textContainerRect.width / 2;
                        const containerCenterY = textContainerRect.top + textContainerRect.height / 2;

                        const distance = Math.sqrt(Math.pow(charCenterX - containerCenterX, 2) + Math.pow(charCenterY - containerCenterY, 2));
                        // 画面全体の対角線長を最大距離とする
                        const maxDistance = Math.sqrt(Math.pow(window.innerWidth, 2) + Math.pow(window.innerHeight, 2)) / 2;
                        const normalizedDistance = distance / maxDistance; // 0から1の範囲に正規化

                        // 落下開始のディレイを調整（全体で6秒の間に均等に広がるように）
                        // 3秒から9秒（3秒開始 + 6秒落下）の間にアニメーション終了
                        const fallStartDelay = normalizedDistance * 3; // 中央に近いほど早く落ち始める

                        char.style.animationDelay = `${fallStartDelay}s`; // アニメーション開始までのディレイ
                        char.classList.add('falling');
                    }
                });

                // ⑥ 崩れ落ちた文字が積もり、2秒かけてフェードアウト
                // アニメーションが完了する時間を考慮 (表示から3秒後開始 + 6秒落下 = 9秒)
                setTimeout(() => {
                    allChars.forEach(char => {
                        if (!char.classList.contains('keep-char')) {
                            char.classList.remove('falling');
                            char.classList.add('stacked'); // 積もった状態（透明で下部に移動）
                        }
                    });

                    // 2秒かけてフェードアウト
                    textContainer.style.transition = 'opacity 2s ease-out';
                    textContainer.style.opacity = '0';

                    // ⑦ ⑥のフェードアウトの2秒間のあと、残った文字が移動
                    setTimeout(() => {
                        textContainer.style.display = 'none'; // 元のテキストコンテナを非表示にする

                        // 残った文字を画面中央に配置する新しいコンテナを作成
                        const finalStorytellerContainer = document.createElement('div');
                        finalStorytellerContainer.id = 'final-storyteller-container';
                        document.body.appendChild(finalStorytellerContainer);

                        // 残す文字を正しい順序で新しいコンテナに追加
                        // dataset.charIndex を使って正しい順序で並べる
                        keptCharSpans.sort((a, b) => a.dataset.charIndex - b.dataset.charIndex);

                        keptCharSpans.forEach(span => {
                            // 元の位置から中央へのスムーズな移動を実現するため、
                            // JavaScriptで初期位置を保持し、CSSで最終位置に移行させる
                            const rect = span.getBoundingClientRect();
                            span.style.left = `${rect.left}px`;
                            span.style.top = `${rect.top}px`;
                            span.style.position = 'fixed'; // 初期位置を固定

                            span.classList.remove('char'); // 既存のcharクラスを削除
                            span.classList.add('storyteller-final'); // 新しいクラスを追加
                            span.style.opacity = '1'; // 確実に表示
                            finalStorytellerContainer.appendChild(span);
                        });

                        // 2秒かけて中央に並ぶアニメーションを開始
                        // 短いディレイでCSSトランジションをトリガー
                        setTimeout(() => {
                            keptCharSpans.forEach(span => {
                                // CSSのtransitionで中央へ移動
                                span.style.left = '50%';
                                span.style.top = '50%';
                                span.style.transform = 'translate(-50%, -50%)'; // 中央揃え
                                span.classList.add('enlarged'); // ⑧ 拡大アニメーション開始
                            });
                        }, 50); // わずかなディレイ
                    }, 9000 + 2000); // 3秒(表示から落下開始) + 6秒(落下時間) + 2秒(フェードアウト) = 11秒後に処理開始
                }, 9000); // 3秒(表示から落下開始) + 6秒(落下時間) = 9秒後に積もる処理開始
            }, 3000); // ③の文章が表示されてから3秒後
        });
    </script>
</body>
</html>
