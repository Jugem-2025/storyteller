<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Text Animation</title>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;500&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #E81F27;
            font-family: 'Oswald', sans-serif;
            color: white;
            margin: 0;
            overflow: hidden; /* 崩れる文字がはみ出さないように */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            position: relative;
        }

        #initial-text-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%; /* テキストが収まるように調整 */
            text-align: center;
            line-height: 1.2;
            font-size: 2.5vw; /* 画面サイズに合わせて調整 */
            user-select: none; /* 文字選択を防止 */
            z-index: 10;
            opacity: 1;
        }

        .char-wrapper {
            display: inline-block;
            position: relative;
            white-space: pre; /* 空白が連続してもそのまま表示されるように */
        }

        .falling-char {
            position: absolute;
            left: 0;
            top: 0;
            transform: translate(0, 0);
            opacity: 1;
            transition: opacity 0.5s ease-out; /* フェードアウト用 */
            pointer-events: none; /* クリック不可に */
            user-select: none;
        }

        .remaining-char {
            position: relative; /* 中央配置のためにrelative */
            display: inline-block;
            opacity: 1;
            transform: scale(1);
            transition: transform 2s ease-in-out; /* 拡大アニメーション */
            white-space: pre; /* 空白が連続してもそのまま表示されるように */
            font-size: inherit; /* 初期フォントサイズを継承 */
            z-index: 15; /* storytelerが上に表示されるように */
        }

        #pile-container {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100px; /* 積もる領域の目安 */
            overflow: hidden;
            z-index: 5;
            pointer-events: none;
        }

        .piled-char {
            position: absolute;
            color: white;
            opacity: 1;
            transition: opacity 2s ease-out; /* 積もった文字のフェードアウト */
            pointer-events: none;
            user-select: none;
        }

        #final-storyteller {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1);
            white-space: nowrap;
            opacity: 0; /* 最初は非表示 */
            z-index: 20;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="initial-text-container"></div>
    <div id="pile-container"></div>
    <div id="final-storyteller"></div>

    <script>
        const initialText = `FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR
FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR
FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR`;

        const initialTextContainer = document.getElementById('initial-text-container');
        const pileContainer = document.getElementById('pile-container');
        const finalStoryteller = document.getElementById('final-storyteller');

        const targetChars = ['s', 't', 'o', 'r', 'y', 't', 'e', 'l', 'l', 'e', 'r'];
        let charElements = [];
        let remainingCharIndices = [];
        let foundCharCount = 0;

        // 文字をspanでラップしてDOMに追加
        function setupInitialText() {
            let tempHTML = '';
            for (let i = 0; i < initialText.length; i++) {
                const char = initialText[i];
                // 空白文字の場合は特別な処理
                if (char === ' ' || char === '\n') {
                    tempHTML += `<span class="char-wrapper" data-char="${char}">`;
                    if (char === ' ') {
                        tempHTML += '&nbsp;'; // 半角スペース
                    } else {
                        tempHTML += '<br>'; // 改行
                    }
                    tempHTML += '</span>';
                } else {
                    tempHTML += `<span class="char-wrapper" data-char="${char}">${char}</span>`;
                }
            }
            initialTextContainer.innerHTML = tempHTML;
            charElements = Array.from(initialTextContainer.querySelectorAll('.char-wrapper'));

            // 残す文字のインデックスを決定
            let tempRemainingIndices = [];
            let startIndex = 0;
            targetChars.forEach(targetChar => {
                let found = false;
                for (let i = startIndex; i < charElements.length; i++) {
                    const charElement = charElements[i];
                    const char = charElement.dataset.char.toLowerCase();
                    // 空白文字は対象外、かつターゲット文字と一致するか
                    if (char !== ' ' && char !== '\n' && char === targetChar) {
                        if (!tempRemainingIndices.includes(i)) { // 連続しないように既に選ばれていないか確認
                            tempRemainingIndices.push(i);
                            startIndex = i + 1; // 次の検索開始位置を更新
                            found = true;
                            break;
                        }
                    }
                }
                if (!found) {
                    // もし見つからなかった場合、最初から探すなどして柔軟に対応するか、エラーとするか
                    // 今回は、見つからない場合は処理をスキップし、残る文字が少なくなることを許容
                    console.warn(`Target character '${targetChar}' not found or cannot be placed non-continuously.`);
                }
            });
            // 残す文字のインデックスをシャッフルしてから、targetCharsの順番に並べる
            // これは「バラけた場所」と「この順番で残る」という要件を両立させるため
            // 実際は、元の文章中の異なる場所から文字を選んで、最後にその文字たちをstorytellerの順番に並べ直す
            remainingCharIndices = tempRemainingIndices.sort((a, b) => a - b); // 実際の表示位置を保持するためにソート

            // 最終的に表示されるstorytellerの文字を作成
            finalStoryteller.innerHTML = targetChars.map(char => `<span class="remaining-char">${char}</span>`).join('');
            finalStoryteller.style.opacity = 0; // 初期は非表示
        }


        // 文字を崩すアニメーション
        function startFallingAnimation() {
            charElements.forEach((charElement, index) => {
                const char = charElement.dataset.char;

                // 残す文字のインデックスに含まれていない場合は崩す
                if (!remainingCharIndices.includes(index)) {
                    const rect = charElement.getBoundingClientRect();
                    const initialX = rect.left + window.scrollX;
                    const initialY = rect.top + window.scrollY;
                    const fontSize = parseFloat(window.getComputedStyle(charElement).fontSize);

                    // 崩れる文字の要素を新しく作成
                    const fallingCharDiv = document.createElement('div');
                    fallingCharDiv.classList.add('falling-char');
                    fallingCharDiv.textContent = char === '\n' ? '' : char; // 改行文字は表示しない
                    fallingCharDiv.style.cssText = `
                        position: fixed; /* 画面固定で動かす */
                        left: ${initialX}px;
                        top: ${initialY}px;
                        font-size: ${fontSize}px;
                        pointer-events: none;
                        user-select: none;
                        z-index: 10;
                    `;
                    document.body.appendChild(fallingCharDiv);

                    // 初期テキストの文字は非表示に
                    charElement.style.opacity = 0;

                    // アニメーション開始
                    const duration = Math.random() * 0.5 + 0.8; // 0.8秒から1.3秒
                    const delay = Math.random() * 0.2; // 少しランダムな遅延
                    const targetY = window.innerHeight - (Math.random() * 50 + 20); // 画面下部に積もるように
                    const targetX = Math.random() * (window.innerWidth - fontSize * 2) + fontSize; // ランダムなX位置

                    fallingCharDiv.animate([
                        { transform: 'translate(0, 0)', opacity: 1 },
                        { transform: `translate(${targetX - initialX}px, ${targetY - initialY}px)`, opacity: 1 }
                    ], {
                        duration: duration * 1000,
                        delay: delay * 1000,
                        easing: 'ease-in',
                        fill: 'forwards'
                    }).onfinish = () => {
                        // アニメーション終了後、積もる文字として配置
                        const piledChar = document.createElement('div');
                        piledChar.classList.add('piled-char');
                        piledChar.textContent = char === '\n' ? '' : char;
                        piledChar.style.cssText = `
                            left: ${targetX}px;
                            top: ${targetY}px;
                            font-size: ${fontSize}px;
                        `;
                        pileContainer.appendChild(piledChar);
                        fallingCharDiv.remove(); // 崩れる文字は削除

                        foundCharCount++;
                        if (foundCharCount === charElements.length - remainingCharIndices.length) {
                            // 全ての文字が積もり終わったらフェードアウトとstorytellerアニメーションを開始
                            startPileFadeOutAndStorytellerAnimation();
                        }
                    };
                } else {
                    // 残る文字は元の位置に残す
                    charElement.classList.add('remaining-char-initial-pos'); // 後で調整する用のクラス
                }
            });
            initialTextContainer.style.opacity = 0; // 全体が消えるように
        }

        function startPileFadeOutAndStorytellerAnimation() {
            // 積もった文字をフェードアウト
            const piledChars = document.querySelectorAll('.piled-char');
            piledChars.forEach(char => {
                char.style.opacity = 0; // CSS transitionで2秒かけてフェードアウト
            });

            // "storyteller" を中央に配置し、拡大アニメーション
            finalStoryteller.style.opacity = 1;
            const finalChars = finalStoryteller.querySelectorAll('.remaining-char');
            finalChars.forEach((charSpan, i) => {
                // ここで「バラけた場所から集まる」挙動を擬似的に表現
                // 初期位置はランダムまたは元の位置に近しい場所から中央へ集まるように見せる
                // 今回はシンプルに、最初から中央に集まっている状態から拡大する
                charSpan.style.transform = 'scale(3)'; // 最終的な拡大サイズ
            });

            finalStoryteller.animate([
                { transform: 'translate(-50%, -50%) scale(1)', opacity: 1 },
                { transform: 'translate(-50%, -50%) scale(3)', opacity: 1 }
            ], {
                duration: 2000, // 2秒
                easing: 'ease-in-out', // ヌルッとした挙動
                fill: 'forwards'
            });
        }


        // 初期化処理
        document.addEventListener('DOMContentLoaded', () => {
            setupInitialText();

            // 3秒後にアニメーション開始
            setTimeout(() => {
                startFallingAnimation();
            }, 3000);
        });
    </script>
</body>
</html>
