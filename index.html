<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Text Animation</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@500&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #E81F27; /* ① 背景の色 */
            font-family: 'Oswald', sans-serif; /* ② フォント */
            color: black; /* ② 文字の色 */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            position: relative;
        }

        #text-container {
            text-align: center;
            line-height: 1.2;
            word-break: break-all; /* 単語の途中で改行を許可 */
            font-size: 3vw; /* ② 文字のサイズ */
            position: relative;
            padding: 2vw; /* 文字が端に寄りすぎないようにパディング */
        }

        .char {
            display: inline-block;
            position: relative;
            opacity: 1;
            transform: translateY(0) rotate(0deg);
            transition: opacity 0.5s, transform 0.5s; /* フェードアウト時に使用 */
            will-change: transform, opacity; /* アニメーションのパフォーマンス最適化 */
        }

        .char.falling {
            animation: fall 6s forwards; /* ④ 6秒かけて崩れ落ちる */
            animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1); /* ヌルっとした落下 */
        }

        /* 落下アニメーション（下方向、回転、左右の揺れを表現） */
        @keyframes fall {
            0% {
                opacity: 1;
                transform: translateY(0) rotate(0deg) translateX(0);
            }
            100% {
                opacity: 0; /* 崩れ落ちる途中で消えるように */
                transform: translateY(100vh) rotate(var(--rotate-deg, 360deg)) translateX(var(--shake-x, 0px)); /* 下方向、回転、左右揺れ */
            }
        }

        /* 文字の積もりアニメーション後の状態（透明で画面下部に移動） */
        .char.stacked {
            opacity: 0;
            transform: translateY(calc(100vh - 3vw)) rotate(0deg); /* 画面下部に積もる */
        }

        /* 残った文字の移動と拡大 */
        .char.storyteller-final {
            position: absolute; /* 絶対位置指定で中央に配置 */
            opacity: 1;
            transform: translate(-50%, -50%) scale(1); /* 初期状態 */
            transition: transform 2s ease-in-out, font-size 2s ease-in-out, letter-spacing 2s ease-in-out; /* ⑧ ヌルっとした拡大と文字間隔調整 */
            font-size: 3vw; /* 拡大前のサイズ */
            letter-spacing: normal; /* 拡大前の文字間隔 */
        }

        .char.storyteller-final.enlarged {
            font-size: 9vw; /* ⑧ 3倍の大きさ */
            letter-spacing: 0.15em; /* 文字間隔を広げる（調整が必要な可能性あり） */
            transform: translate(-50%, -50%) scale(1); /* 拡大はfont-sizeで行うためscaleは1を維持 */
        }
    </style>
</head>
<body>
    <div id="text-container"></div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const textContainer = document.getElementById('text-container');
            const fullText = `FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR
FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR
FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR`; // ③ 初期表示文章

            const charsToKeep = ['s', 't', 'o', 'r', 'y', 't', 'e', 'l', 'l', 'e', 'r']; // ⑤ 残す文字
            let keptCharSpans = [];
            let currentKeptCharIndex = 0;

            // 各文字をspanでラップ
            fullText.split('').forEach((char, index) => {
                const charSpan = document.createElement('span');
                charSpan.textContent = char;
                charSpan.classList.add('char');

                // 残す文字を特定し、クラスを追加
                if (currentKeptCharIndex < charsToKeep.length && char.toLowerCase() === charsToKeep[currentKeptCharIndex]) {
                    charSpan.classList.add('keep-char');
                    charSpan.dataset.charIndex = currentKeptCharIndex; // 何番目の残す文字か記録
                    keptCharSpans.push(charSpan);
                    currentKeptCharIndex++;
                }
                textContainer.appendChild(charSpan);
            });

            const allChars = document.querySelectorAll('.char');

            // ④ 3秒後に文字が崩れ落ち始める
            setTimeout(() => {
                let fallingDelay = 0; // 各文字の落下開始を遅らせるためのディレイ
                allChars.forEach((char, index) => {
                    if (!char.classList.contains('keep-char')) {
                        // ランダムな回転と左右の揺れを設定
                        const randomRotate = Math.random() * 720 - 360; // -360degから360deg
                        const randomShakeX = Math.random() * 60 - 30; // -30pxから30px

                        char.style.setProperty('--rotate-deg', `${randomRotate}deg`);
                        char.style.setProperty('--shake-x', `${randomShakeX}px`);

                        // 波紋のように広がる表現のため、中央からの距離に応じて落下開始を遅延
                        const textContainerRect = textContainer.getBoundingClientRect();
                        const charRect = char.getBoundingClientRect();
                        const charCenterX = charRect.left + charRect.width / 2;
                        const charCenterY = charRect.top + charRect.height / 2;
                        const containerCenterX = textContainerRect.left + textContainerRect.width / 2;
                        const containerCenterY = textContainerRect.top + textContainerRect.height / 2;

                        const distance = Math.sqrt(Math.pow(charCenterX - containerCenterX, 2) + Math.pow(charCenterY - containerCenterY, 2));
                        const maxDistance = Math.sqrt(Math.pow(textContainerRect.width / 2, 2) + Math.pow(textContainerRect.height / 2, 2));
                        const normalizedDistance = distance / maxDistance; // 0から1の範囲に正規化

                        // 落下開始のディレイを調整（全体で6秒の間に均等に広がるように）
                        const fallStartDelay = 3 + (normalizedDistance * 3); // 3秒から6秒の間に落下開始

                        char.style.animationDelay = `${fallStartDelay}s`;
                        char.classList.add('falling');
                    }
                });

                // ⑥ 崩れ落ちた文字が積もり、2秒かけてフェードアウト
                // アニメーションが完了する時間を考慮 (3秒開始 + 6秒落下 = 9秒)
                setTimeout(() => {
                    allChars.forEach(char => {
                        if (!char.classList.contains('keep-char')) {
                            char.classList.remove('falling');
                            char.classList.add('stacked'); // 積もった状態（透明で下部に移動）
                        }
                    });

                    // 2秒かけてフェードアウト
                    textContainer.style.transition = 'opacity 2s ease-out';
                    textContainer.style.opacity = '0';

                    // ⑦ ⑥のフェードアウトの2秒間のあと、残った文字が移動
                    setTimeout(() => {
                        textContainer.style.display = 'none'; // テキストコンテナを非表示にする

                        // 残った文字を画面中央に配置
                        const finalStorytellerContainer = document.createElement('div');
                        finalStorytellerContainer.id = 'final-storyteller-container';
                        finalStorytellerContainer.style.position = 'fixed';
                        finalStorytellerContainer.style.top = '50%';
                        finalStorytellerContainer.style.left = '50%';
                        finalStorytellerContainer.style.transform = 'translate(-50%, -50%)';
                        finalStorytellerContainer.style.display = 'flex';
                        finalStorytellerContainer.style.justifyContent = 'center';
                        finalStorytellerContainer.style.alignItems = 'center';
                        finalStorytellerContainer.style.zIndex = '100'; // 他の要素より手前に

                        keptCharSpans.forEach(span => {
                            span.classList.remove('char'); // 既存のcharクラスを削除
                            span.classList.add('storyteller-final'); // 新しいクラスを追加
                            span.style.position = 'relative'; // flexbox内で位置調整するため
                            span.style.left = '0';
                            span.style.top = '0';
                            span.style.transform = 'none'; // 初期状態に戻す
                            span.style.opacity = '1'; // 確実に表示
                            finalStorytellerContainer.appendChild(span);
                        });
                        document.body.appendChild(finalStorytellerContainer);

                        // 2秒かけて中央に並ぶ (flexboxとtransitionで自動的に実現)
                        // ⑧ その2秒間の間、文字列の文字サイズを徐々に拡大し、もとの3倍の大きさにする
                        setTimeout(() => {
                            keptCharSpans.forEach(span => {
                                span.classList.add('enlarged'); // 拡大アニメーション開始
                            });
                        }, 10); // 短いディレイでCSSトランジションをトリガー
                    }, 9000 + 2000); // 3秒(表示から落下開始) + 6秒(落下時間) + 2秒(フェードアウト) = 11秒
                }, 9000); // 3秒(表示から落下開始) + 6秒(落下時間) = 9秒後に積もる処理開始
            }, 3000); // ③の文章が表示されてから3秒後
        });
    </script>
</body>
</html>
