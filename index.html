<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Text Effect</title>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@500&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #E81F27; /* ① 背景の色 */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* 崩れた文字がはみ出さないように */
            font-family: 'Oswald', sans-serif; /* ② フォント: Oswald Medium */
            font-weight: 500; /* Oswald Mediumに対応する重み */
            color: black; /* ② 文字の色: 黒 */
            perspective: 1000px; /* 3D効果のため */
        }

        .text-container {
            position: relative;
            text-align: center;
            line-height: 1.2; /* 行の高さを調整 */
            user-select: none; /* テキスト選択を無効化 */
            padding-top: 5vw; /* ③ 上部の余白 */
            padding-left: 3vw; /* ③ 左右の余白 */
            padding-right: 3vw; /* ③ 左右の余白 */
            box-sizing: border-box; /* paddingを含めて幅を計算 */
            width: 100vw; /* 画面幅いっぱいに広げる */
            height: 100vh; /* 画面高さいっぱいに広げる */
            display: flex; /* flexboxで中央寄せを解除し、paddingを反映 */
            flex-wrap: wrap; /* 文字列が折り返すように */
            align-content: flex-start; /* 上から配置を開始 */
            justify-content: center; /* 行内での中央揃えを維持 */
        }

        .char-wrapper {
            display: inline-block;
            position: relative;
            white-space: pre; /* 半角スペースや改行を保持 */
        }

        .char {
            display: inline-block;
            font-size: 3vw; /* ② 文字サイズ: 3vw */
            opacity: 1;
            transform: translateZ(0); /* ハードウェアアクセラレーションを有効に */
            transition: transform 0.5s ease-out, opacity 0.5s ease-out, top 0.5s ease-out, left 0.5s ease-out; /* 残る文字の移動用 */
            will-change: transform, opacity, top, left; /* アニメーションのパフォーマンス改善 */
        }

        /* 崩れる文字のアニメーション */
        .char.fall {
            animation: fallAnimation 6s forwards; /* ④ 6秒かけて崩れ落ちる */
            animation-timing-function: cubic-bezier(0.25, 0.46, 0.45, 0.94); /* 浮遊感のあるイージング */
        }

        @keyframes fallAnimation {
            0% {
                transform: translateY(0) rotateX(0deg) rotateY(0deg) rotateZ(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotateX(720deg) rotateY(720deg) rotateZ(720deg); /* 下方向に落ちて回転 */
                opacity: 0; /* 画面下部に積もるように見せるため透明に */
            }
        }

        /* 残る文字のスタイル */
        .char.remain {
            opacity: 1; /* 残る文字は透明にしない */
            color: black; /* 残る文字の色は黒を維持 */
        }

        /* 残った文字の最終的なスタイル（storyteller） */
        .final-storyteller {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1);
            white-space: nowrap;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0; /* 最初は非表示 */
            transition: all 2s ease-in-out; /* ⑦, ⑧ ヌルッとした移動と拡大、2秒間 */
            z-index: 10;
        }

        .final-storyteller.active {
            opacity: 1;
            transform: translate(-50%, -50%) scale(3); /* ⑧ 3倍に拡大 */
            letter-spacing: 0.5em; /* ⑧ 文字間隔を広げる（縦横比維持のため調整） */
        }
    </style>
</head>
<body>
    <div class="text-container" id="textContainer"></div>
    <div class="final-storyteller" id="finalStoryteller"></div>

    <script>
        const originalText = `FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR
FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR
FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR`; // ③ ページ表示時の文章

        const textContainer = document.getElementById('textContainer');
        const finalStoryteller = document.getElementById('finalStoryteller');
        const chars = [];
        const targetRemainChars = ['s', 't', 'o', 'r', 'y', 't', 'e', 'l', 'l', 'e', 'r']; // ⑤ 残る文字
        const remainingCharIndices = [];

        // テキストを分解し、span要素としてDOMに追加
        originalText.split('').forEach((char, index) => {
            const charWrapper = document.createElement('span');
            charWrapper.classList.add('char-wrapper');

            const charSpan = document.createElement('span');
            charSpan.classList.add('char');
            charSpan.textContent = char;

            charWrapper.appendChild(charSpan);
            textContainer.appendChild(charWrapper);
            chars.push({ wrapper: charWrapper, span: charSpan, originalChar: char });
        });

        // 残す文字のインデックスをランダムに選定（連続しないように、かつ文中から広く）
        function selectRemainingChars() {
            let availableIndices = [];
            for (let i = 0; i < chars.length; i++) {
                // スペースや改行は残す文字の対象外とする
                if (chars[i].originalChar.trim() !== '') {
                    availableIndices.push(i);
                }
            }

            // 残す文字のターゲットリストを複製し、選定済みをマークするためのセット
            const tempTargetChars = [...targetRemainChars];
            const selectedOriginalIndices = new Set();

            tempTargetChars.forEach(targetChar => {
                let foundIndex = -1;
                // 利用可能なインデックスをシャッフルして、ランダム性と分散性を高める
                let shuffledAvailable = [...availableIndices].sort(() => 0.5 - Math.random());

                for (const idx of shuffledAvailable) {
                    if (chars[idx].originalChar.toLowerCase() === targetChar.toLowerCase() && !selectedOriginalIndices.has(idx)) {
                        foundIndex = idx;
                        break;
                    }
                }

                if (foundIndex !== -1) {
                    remainingCharIndices.push(foundIndex);
                    selectedOriginalIndices.add(foundIndex);
                    // 選ばれたインデックスは以降の検索対象から除外
                    availableIndices = availableIndices.filter(item => item !== foundIndex);
                }
            });

            // 万が一、選ばれた文字数が足りない場合の補足（ただし、これはロジック上発生しにくいように工夫済み）
            // console.log("選ばれた残る文字の数:", remainingCharIndices.length);
        }

        // ④ ページ表示から3秒後に文字を崩し始める
        setTimeout(() => {
            selectRemainingChars(); // 残す文字のインデックスを決定

            const triggerPointX = window.innerWidth / 3; // 最上部の左から3分の1
            const triggerPointY = 0;

            const maxDistance = Math.sqrt(Math.pow(window.innerWidth - triggerPointX, 2) + Math.pow(window.innerHeight - triggerPointY, 2));

            chars.forEach((charObj, index) => {
                const charSpan = charObj.span;

                // 残す文字に含まれていない、かつスペースや改行でない文字のみ崩壊アニメーションの対象とする
                if (!remainingCharIndices.includes(index) && charObj.originalChar.trim() !== '') {
                    const rect = charSpan.getBoundingClientRect(); // 各文字の位置を取得

                    // 距離に基づいて遅延を計算し、波紋のように広がる効果を作成
                    // 崩れ落ちる範囲が急速に大きくなるように、遅延計算の関数を調整
                    // 例: 距離の二乗や、より急なカーブを持つ関数を適用
                    const distance = Math.sqrt(Math.pow(rect.left - triggerPointX, 2) + Math.pow(rect.top - triggerPointY, 2));
                    // 遅延の最大値を設定し、距離に応じて非線形に遅延を増加させる
                    // ここで、崩壊範囲が急速に大きくなるように調整 (例: distanceの累乗)
                    const normalizedDistance = distance / maxDistance; // 0から1に正規化
                    const delay = Math.pow(normalizedDistance, 0.7) * 3; // 0.7は調整可能。小さいほど開始が早まり、広い範囲に早く伝播

                    charSpan.style.animationDelay = `${delay}s`;
                    charSpan.classList.add('fall');
                } else if (remainingCharIndices.includes(index)) {
                    // ⑤ 残る文字は透明などには変更せず、そのままの色(黒)を維持する
                    charSpan.classList.add('remain');
                }
            });

            // ④ 文字が落ち始めるのが表示から3秒後、文字が落ちる時間は表示から8秒〜10秒 (全体で6秒のアニメーション)
            // 全体が6秒かけて崩れ落ちるアニメーションが終了した後、フェードアウトを開始
            setTimeout(() => {
                // ⑥ 崩れ落ちた文字は表示された画面の下部に積もるようにする。（opacity: 0; と animation-fill-mode: forwards; で実現）
                // ⑥ 崩れ落ちた文字が全て積もったら、2秒かけてフェードアウトする。
                textContainer.style.transition = 'opacity 2s ease-out';
                textContainer.style.opacity = 0; // 全体がフェードアウト
            }, 3000 + 6000); // 表示から3秒 + 崩壊に6秒 = 9秒後にフェードアウト開始

            // ⑥のフェードアウトのあと、⑦で指定した崩れ落ちなかった文字(残った文字「s, t, o, r, y, t, e, l, l, e, r」)が位置を変える。
            // ⑦ それらの文字が2秒かけてヌルッと移動しはじめ、画面中央に向かう。向かいながら「storyteller」の順番で画面中央に並ぶ。
            // ⑧ その2秒間の間、その文字列「storyteller」の文字サイズを徐々に拡大し、もとの3倍の大きさにする。拡大はヌルッとした挙動になるようにする。
            // ⑧ また拡大中に文字と文字の間を広げ、整列した文字列の文字間隔を含む全体の縦横比が、整列する前の文字列の全体の縦横比と変わらないようにする。
            // ⑨ ⑧で表示されたstorytellerは、その後消えずに残る

            setTimeout(() => {
                textContainer.style.display = 'none'; // テキストコンテナを完全に非表示にする

                // ⑦ 残った文字を「storyteller」の順番で並べるための処理
                // ここで重要なのは、remainingCharIndicesに含まれる文字の中から、targetRemainCharsの順番に合致する文字を選び、
                // finalStorytellerに新しいspanとして追加すること。
                const finalStorytellerChars = [];
                const usedOriginalIndices = new Set(); // 既にfinalStorytellerCharsに追加された元のインデックスを追跡

                targetRemainChars.forEach(targetChar => {
                    let foundCharObj = null;
                    // remainingCharIndicesの中から、targetCharに一致し、かつまだ使われていない文字を探す
                    for (const originalIdx of remainingCharIndices) {
                        if (!usedOriginalIndices.has(originalIdx) && chars[originalIdx].originalChar.toLowerCase() === targetChar.toLowerCase()) {
                            foundCharObj = chars[originalIdx];
                            break;
                        }
                    }
                    if (foundCharObj) {
                        finalStorytellerChars.push(foundCharObj);
                        usedOriginalIndices.add(foundCharObj.span.dataset.originalIndex ? parseInt(foundCharObj.span.dataset.originalIndex) : chars.indexOf(foundCharObj)); // 既に設定済みならそれを使う
                    } else {
                        // もし指定された文字がremainingCharIndices内に見つからない場合は、
                        // 便宜上、利用可能な残る文字の中からランダムに選択するか、ダミー文字を追加することも考えられますが、
                        // 今回の指示では「正しく残るようになっているかを確認」とあるため、見つからない場合はロジックに問題がある可能性。
                        // 今回は厳密に指定文字のみ残るようになっている前提で処理。
                        console.warn(`Warning: Could not find a suitable character for '${targetChar}' among remaining ones.`);
                    }
                });

                // finalStorytellerに文字を追加
                finalStorytellerChars.forEach(charObj => {
                    const charSpan = document.createElement('span');
                    charSpan.textContent = charObj.span.textContent; // 元の文字のテキストを使用
                    charSpan.classList.add('char'); // 基本的なスタイルを適用
                    charSpan.style.fontSize = '3vw'; // 初期サイズを設定
                    finalStoryteller.appendChild(charSpan);
                    charObj.span.style.opacity = 0; // 元の位置の文字を非表示に
                    charObj.span.style.pointerEvents = 'none'; // イベントも無効に
                });

                finalStoryteller.classList.add('active'); // ヌルッと移動と拡大アニメーションを開始

            }, 3000 + 6000 + 2000); // 崩壊開始3秒 + 崩壊6秒 + フェードアウト2秒 = 11秒後に集約開始

        }, 3000); // ページ表示から3秒後に実行
    </script>
</body>
</html>
