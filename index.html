<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animated Text</title>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;500&display=swap" rel="stylesheet">
    <style>
        @font-face {
            font-family: 'Storyteller';
            src: url('path/to/Storyteller-Regular.woff2') format('woff2'),
                 url('path/to/Storyteller-Regular.woff') format('woff');
            /* Storytellerフォントのパスを正確に指定してください */
            /* 必要であれば他の形式 (e.g., .ttf) も追加 */
            font-weight: normal;
            font-style: normal;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #E81F27; /* 背景色を#E81F27に変更 */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Oswald', sans-serif; /* 文章のフォントをOswaldに設定 */
            font-weight: 500; /* Oswald Mediumに相当 */
            color: #000000; /* 文字色を黒に設定 */
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            /* display: flex; はbodyで設定済みなので不要 */
            /* justify-content: center; align-items: center; もbodyで設定済み */
            padding: 20px;
            box-sizing: border-box;
            overflow: hidden; /* 子要素のはみ出しを隠す */
        }

        .text-wrapper {
            position: absolute; /* 画面中央に配置 */
            width: 80vw;
            max-width: 1200px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-wrap: wrap;
            justify-content: center; /* 中央揃え */
            white-space: pre-wrap;
            line-height: 1.5;
            text-align: center; /* 中央揃え */
            font-size: 10px;
            opacity: 0; /* 最初は非表示 */
            animation: fadeInText 0.5s forwards;
            animation-delay: 0.5s;
            pointer-events: none; /* マウスイベントを受け付けない */
        }

        .falling-char {
            display: inline-block;
            opacity: 1;
            transform: translateY(0) rotate(0deg);
            animation-timing-function: cubic-bezier(0.68, -0.55, 0.27, 1.55); /* 最初のカーブに戻す */
            position: relative; /* z-indexのためにrelativeに */
            z-index: 2; /* 崩れる文字が手前になるように */
            will-change: transform, opacity; /* アニメーションのパフォーマンス最適化 */
        }

        @keyframes fadeInText {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes fall-from-center { /* 中央から広がるアニメーション */
            0% {
                opacity: 1;
                transform: translate(0, 0) rotate(0deg); /* 最初の位置 */
            }
            100% {
                opacity: 0;
                /* ランダムな方向へ画面外に落下 */
                transform: translate(var(--randX, 0px), var(--randY, 0px)) rotate(var(--randRot, 0deg));
            }
        }

        .remaining-text-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* 中央に配置 */
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Storyteller', cursive;
            font-size: 0; /* 初期サイズを0 */
            color: #000000;
            white-space: nowrap;
            z-index: 3; /* 常に最前面に表示 */
            opacity: 0; /* 初期状態は完全に透明 */
            pointer-events: none; /* マウスイベントを受け付けない */
        }

        .remaining-char {
            display: inline-block;
            opacity: 1; /* 崩れる文字とは異なり、最初から不透明 */
            transform: translate(0, 0) scale(1) rotate(0deg); /* 初期位置は崩れる文字と同じ */
            position: relative; /* その場に残るためrelative */
            font-size: 10px; /* 崩れる文字と同じ初期サイズ */
            z-index: 4; /* remaining-text-containerよりさらに手前 */
            will-change: transform, opacity, font-size;
        }

        /* アニメーション後の状態 */
        .remaining-text-container.show {
            opacity: 1; /* コンテナ全体を不透明にする */
        }

        .remaining-text-container.show .remaining-char {
            animation: assembleAndGrow 1.5s forwards ease-out;
            /* animation-delay はJSで設定 */
        }

        @keyframes assembleAndGrow {
            0% {
                opacity: 0; /* バラバラに散らばる前の状態は透明 */
                transform: translate(var(--x), var(--y)) scale(0) rotate(var(--rot)); /* バラバラの開始位置 */
            }
            1% {
                opacity: 1; /* アニメーション開始直後に不透明に */
            }
            50% {
                opacity: 1;
                transform: translate(0, 0) scale(1.2) rotate(0deg); /* 中央に集まる */
            }
            100% {
                opacity: 1;
                transform: translate(0, 0) scale(1) rotate(0deg); /* 整列して最終サイズ */
                font-size: 80px; /* 最終的なフォントサイズ */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="text-wrapper" id="animatedText">
            </div>
        <div class="remaining-text-container" id="remainingText">
            </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const animatedTextElement = document.getElementById('animatedText');
            const remainingTextContainer = document.getElementById('remainingText');

            const initialText = `FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR
FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR
FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR`;

            const remainingText = "Storyteller";

            // 崩れ落ちる文字を動的に生成
            initialText.split('').forEach((char, index) => {
                const span = document.createElement('span');
                span.classList.add('falling-char');
                span.textContent = char;
                // 各文字のランダムな落下位置と回転を設定
                // 中央からより大きく散らばるように調整
                const randX = (Math.random() - 0.5) * window.innerWidth; // 画面幅全体に散らばる
                const randY = (Math.random() - 0.5) * window.innerHeight; // 画面高全体に散らばる
                const randRot = Math.random() * 1080 - 540; // より大きく回転
                span.style.setProperty('--randX', `${randX}px`);
                span.style.setProperty('--randY', `${randY}px`);
                span.style.setProperty('--randRot', `${randRot}deg`);
                animatedTextElement.appendChild(span);
            });

            // 残る文字を動的に生成し、当初は崩れる文字と同じ位置で表示
            const remainingCharElements = [];
            remainingText.split('').forEach((char, index) => {
                const span = document.createElement('span');
                span.classList.add('remaining-char');
                span.textContent = char;
                // ここではまだランダムな位置を設定しない
                remainingTextContainer.appendChild(span);
                remainingCharElements.push(span);
            });

            // ページロードから3秒後にアニメーションを開始
            const startDelay = 3000; // 3秒 = 3000ミリ秒
            const perCharFallDelay = 0.005; // 各文字の落下開始遅延をさらに短縮し、より一斉に
            const fallAnimationDuration = 2; // falling-charのアニメーションduration
            const assembleAndGrowDuration = 1.5; // remaining-charのアニメーションduration

            setTimeout(() => {
                // 崩れる文字のアニメーションを開始
                const fallingChars = document.querySelectorAll('.falling-char');
                fallingChars.forEach((char, index) => {
                    char.style.animation = `fall-from-center ${fallAnimationDuration}s forwards`;
                    char.style.animationDelay = `${perCharFallDelay * index}s`;
                });

                // 崩れるアニメーションの完了を待ってから残る文字のバラバラアニメーションを開始
                const longestFallingAnimationEndTime = perCharFallDelay * (initialText.length - 1) * 1000 + fallAnimationDuration * 1000;

                setTimeout(() => {
                    // remaining-charの初期位置をランダムに設定し、アニメーションを開始
                    remainingCharElements.forEach((char, index) => {
                        // ランダムな初期位置と回転を設定（中央からの相対位置）
                        const randomX = (Math.random() - 0.5) * 600; // 散らばる範囲を調整
                        const randomY = (Math.random() - 0.5) * 600;
                        const randomRot = Math.random() * 720 - 360;

                        char.style.setProperty('--x', `${randomX}px`);
                        char.style.setProperty('--y', `${randomY}px`);
                        char.style.setProperty('--rot', `${randomRot}deg`);
                        char.style.opacity = '0'; // アニメーション開始前は非表示に
                        char.style.transform = `translate(${randomX}px, ${randomY}px) scale(0) rotate(${randomRot}deg)`; // 初期状態も更新

                        // 実際のassembleAndGrowアニメーションを適用
                        char.style.animation = `assembleAndGrow ${assembleAndGrowDuration}s forwards ease-out`;
                        char.style.animationDelay = `${index * 0.1}s`; // 文字ごとに少し遅延
                    });
                    remainingTextContainer.classList.add('show'); // コンテナ全体を不透明にする
                }, longestFallingAnimationEndTime); // 崩れるアニメーション終了と同時に次のアニメーション開始
            }, startDelay); // ここで3秒の遅延を設定
        });
    </script>
</body>
</html>
