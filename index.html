<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Text Animation</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@500&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #E81F27; /* ① 背景の色 */
            font-family: 'Oswald', sans-serif; /* ② フォント */
            color: black; /* ② 文字の色 */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            position: relative;
        }

        #text-container {
            text-align: center;
            line-height: 1.2;
            word-break: break-all; /* 単語の途中で改行を許可 */
            font-size: 3vw; /* ② 文字のサイズ */
            position: relative;
            padding: 2vw; /* 文字が端に寄りすぎないようにパディング */
        }

        .char {
            display: inline-block;
            position: relative;
            opacity: 1;
            transform: translateY(0) rotate(0deg) translateX(0); /* 初期状態 */
            transition: opacity 0.5s, transform 0.5s; /* フェードアウト時に使用 */
            will-change: transform, opacity; /* アニメーションのパフォーマンス最適化 */
        }

        .char.falling {
            animation: fall 6s forwards; /* ④ 6秒かけて崩れ落ちる */
            animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1); /* ヌルっとした落下 */
        }

        /* 落下アニメーション（下方向、回転、左右の揺れを表現） */
        @keyframes fall {
            0% {
                opacity: 1;
                transform: translateY(0) rotate(0deg) translateX(0);
            }
            100% {
                opacity: 0; /* 崩れ落ちる途中で消えるように */
                transform: translateY(150vh) rotate(var(--rotate-deg, 360deg)) translateX(var(--shake-x, 0px));
            }
        }

        /* 文字の積もりアニメーション後の状態（透明で画面下部に移動） */
        .char.stacked {
            opacity: 0;
            transform: translateY(100vh); /* 画面外へ */
        }

        /* 残った文字の最終的なコンテナ */
        #final-storyteller-container {
            position: fixed; /* 固定位置で中央配置 */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* 自身を中央に */
            display: flex; /* flexboxで中央揃え */
            justify-content: center;
            align-items: center;
            z-index: 100;
            white-space: nowrap; /* 文字列が改行しないように */
            opacity: 0; /* 最初は非表示 */
            transition: opacity 0.1s ease-in; /* 表示時のフェードイン用 */
        }

        /* 残った文字の移動と拡大 */
        .char.storyteller-final {
            color: black; /* ⑤ 残る文字の色は黒のまま */
            opacity: 1; /* 必ず表示 */
            position: fixed; /* 初期位置を固定するため */
            transition: all 2s ease-in-out; /* ⑦ ⑧ ヌルっとした拡大と移動 */
            font-size: 3vw; /* 拡大前のサイズ */
            letter-spacing: normal; /* 拡大前の文字間隔 */
            display: inline-block; /* 各文字をインラインブロックにする */
            /* 初期位置はJavaScriptで設定される */
        }

        .char.storyteller-final.enlarged {
            font-size: 9vw; /* ⑧ 3倍の大きさ */
            letter-spacing: 0.05em; /* 調整後の文字間隔（フォントや文字数で微調整が必要です） */
            /* transformはJavaScriptで設定されるためここでは指定しない */
        }
    </style>
</head>
<body>
    <div id="text-container"></div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const textContainer = document.getElementById('text-container');
            const fullText = `FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR
FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR
FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR`; // ③ 初期表示文章

            const charsToKeep = ['s', 't', 'o', 'r', 'y', 't', 'e', 'l', 'l', 'e', 'r']; // ⑤ 残す文字
            let keptCharSpans = new Array(charsToKeep.length).fill(null); // 指定された順序でspanを格納
            let currentKeptCharIndex = 0;

            const allPossibleKeepChars = []; // 文章中の全てのs,t,o...候補を保持
            let charSpans = []; // 全てのchar spanを順序通りに保持

            // 各文字をspanでラップし、候補を収集
            fullText.split('').forEach((char, index) => {
                const charSpan = document.createElement('span');
                charSpan.textContent = char;
                charSpan.classList.add('char');
                charSpan.dataset.originalIndex = index; // 元のインデックスを保存

                charSpans.push(charSpan);
                textContainer.appendChild(charSpan);

                // 残す文字の候補として、対応する文字とインデックスを保存
                if (char.trim() !== '' && currentKeptCharIndex < charsToKeep.length && char.toLowerCase() === charsToKeep[currentKeptCharIndex]) {
                    allPossibleKeepChars.push({ span: charSpan, originalIndex: index, targetCharIndex: currentKeptCharIndex });
                }
            });

            // ⑤ 残す文字をバラけた場所から選択するロジック
            // 全ての文字のインデックスからランダムに、かつ均等に選ぶ
            // 簡単のため、今回は元のテキストから指定順に抽出するが、バラけ具合を考慮
            // ここでは簡易的に、テキストの長さで分割して各範囲から一つずつ選ぶことを試みます
            const textLength = fullText.length;
            const segmentSize = Math.floor(textLength / charsToKeep.length);
            
            currentKeptCharIndex = 0; // リセット
            for (let i = 0; i < charsToKeep.length; i++) {
                const targetChar = charsToKeep[i];
                let found = false;
                // 適切な範囲で探す (ただし、見つからない場合は全体から探すフォールバックも考慮)
                for (let j = 0; j < charSpans.length; j++) {
                    const charSpan = charSpans[j];
                    // すでに残す文字として選ばれていないこと
                    // 正しい文字であること
                    // そしてまだ保持リストに入っていないこと
                    if (!charSpan.classList.contains('keep-char') && charSpan.textContent.toLowerCase() === targetChar) {
                        charSpan.classList.add('keep-char');
                        charSpan.dataset.charIndex = i; // 何番目の残す文字か記録
                        keptCharSpans[i] = charSpan; // 指定された順序で格納
                        found = true;
                        break; // 次の文字へ
                    }
                }
            }


            const allDisplayChars = document.querySelectorAll('.char'); // 全ての文字span

            // ④ 3秒後に文字が崩れ落ち始める
            setTimeout(() => {
                allDisplayChars.forEach((char) => {
                    if (!char.classList.contains('keep-char')) {
                        // ランダムな回転と左右の揺れを設定
                        const randomRotate = Math.random() * 720 - 360; // -360degから360deg
                        const randomShakeX = Math.random() * 60 - 30; // -30pxから30px

                        char.style.setProperty('--rotate-deg', `${randomRotate}deg`);
                        char.style.setProperty('--shake-x', `${randomShakeX}px`);

                        // 波紋のように広がる表現のため、中央からの距離に応じて落下開始を遅延
                        const textContainerRect = textContainer.getBoundingClientRect();
                        const charRect = char.getBoundingClientRect();
                        const charCenterX = charRect.left + charRect.width / 2;
                        const charCenterY = charRect.top + charRect.height / 2;
                        const containerCenterX = textContainerRect.left + textContainerRect.width / 2;
                        const containerCenterY = textContainerRect.top + textContainerRect.height / 2;

                        const distance = Math.sqrt(Math.pow(charCenterX - containerCenterX, 2) + Math.pow(charCenterY - containerCenterY, 2));
                        const maxDistance = Math.sqrt(Math.pow(window.innerWidth, 2) + Math.pow(window.innerHeight, 2)) / 2;
                        const normalizedDistance = distance / maxDistance; // 0から1の範囲に正規化

                        // 落下開始のディレイを調整（全体で6秒の間に均等に広がるように）
                        const fallStartDelay = normalizedDistance * 3; // 中央に近いほど早く落ち始める (0~3秒の範囲でディレイ)

                        char.style.animationDelay = `${fallStartDelay}s`; // アニメーション開始までのディレイ
                        char.classList.add('falling');
                    }
                });

                // ⑥ 崩れ落ちた文字が積もり、2秒かけてフェードアウト
                // アニメーションが完了する時間を考慮 (表示から3秒後開始 + 6秒落下 = 9秒)
                setTimeout(() => {
                    allDisplayChars.forEach(char => {
                        if (!char.classList.contains('keep-char')) {
                            char.classList.remove('falling');
                            char.classList.add('stacked'); // 積もった状態（透明で下部に移動）
                        }
                    });

                    // 2秒かけてフェードアウト
                    textContainer.style.transition = 'opacity 2s ease-out';
                    textContainer.style.opacity = '0';

                    // ⑦ ⑥のフェードアウトのあと、残った文字が移動
                    // 計算: 3秒(初期表示後待機) + 6秒(落下アニメーション) + 2秒(フェードアウト) = 11秒後
                    setTimeout(() => {
                        textContainer.style.display = 'none'; // 元のテキストコンテナを完全に非表示にする

                        const finalStorytellerContainer = document.createElement('div');
                        finalStorytellerContainer.id = 'final-storyteller-container';
                        document.body.appendChild(finalStorytellerContainer);

                        // 各文字を元の位置から中央へ移動させるために初期位置を設定
                        keptCharSpans.forEach(span => {
                            // spanがnullでないことを確認 (もしcharsToKeepのすべての文字が見つからなかった場合のため)
                            if (span) {
                                const rect = span.getBoundingClientRect();
                                span.style.left = `${rect.left}px`;
                                span.style.top = `${rect.top}px`;
                                span.classList.remove('char'); // 既存のcharクラスを削除
                                span.classList.add('storyteller-final'); // 新しいクラスを追加
                                span.style.opacity = '1'; // 確実に表示
                                finalStorytellerContainer.appendChild(span);
                            }
                        });

                        // CSSトランジションをトリガーして移動と拡大を開始
                        // 短いディレイを設けることで、初期位置設定が完了してからアニメーションが始まる
                        setTimeout(() => {
                            finalStorytellerContainer.style.opacity = '1'; // コンテナを表示
                            keptCharSpans.forEach((span, i) => {
                                if (span) {
                                    // 各文字がfinal-storyteller-container内で正しい順序で並ぶように
                                    // transformプロパティを調整（CSSでflexboxが適用されるため、個別のtranslateは不要になる）
                                    // ただし、拡大アニメーションは引き続き適用
                                    span.classList.add('enlarged'); // ⑧ 拡大アニメーション開始
                                    // flexboxで整列されるため、個別のtranslateXは不要
                                    // 縦横比維持のため、letter-spacingもenlargedクラスで調整
                                }
                            });
                        }, 50); // わずかなディレイ
                    }, 3000 + 6000 + 2000); // 11秒後に処理開始
                }, 3000 + 6000); // 9秒後に積もる処理開始 (落下完了後)
            }, 3000); // ③の文章が表示されてから3秒後
        });
    </script>
</body>
</html>
