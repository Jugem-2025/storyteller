<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animated Text</title>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;500&display=swap" rel="stylesheet">
    <style>
        @font-face {
            font-family: 'Storyteller';
            src: url('path/to/Storyteller-Regular.woff2') format('woff2'),
                 url('path/to/Storyteller-Regular.woff') format('woff');
            /* Storytellerフォントのパスを正確に指定してください */
            /* 必要であれば他の形式 (e.g., .ttf) も追加 */
            font-weight: normal;
            font-style: normal;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #E81F27; /* 背景色を#E81F27に変更 */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Oswald', sans-serif; /* 文章のフォントをOswaldに設定 */
            font-weight: 500; /* Oswald Mediumに相当 */
            color: #000000; /* 文字色を黒に設定 */
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex; /* 中央配置のためにflexを使用 */
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
        }

        .text-wrapper {
            position: absolute; /* 以前のabsoluteに戻し、中央に配置 */
            width: 80vw; /* 広めの幅を維持 */
            max-width: 1200px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-wrap: wrap;
            justify-content: center; /* 中央揃えに戻す */
            white-space: pre-wrap;
            line-height: 1.5; /* 行の高さを元に戻す */
            text-align: center; /* 中央揃え */
            font-size: 10px; /* フォントサイズを維持 */
            opacity: 0; /* 最初は非表示 */
            animation: fadeInText 0.5s forwards;
            animation-delay: 0.5s;
        }

        .falling-char {
            display: inline-block;
            opacity: 1;
            transform: translateY(0) rotate(0deg);
            animation-timing-function: cubic-bezier(0.68, -0.55, 0.27, 1.55); /* 最初のカーブに戻す */
            position: relative; /* z-indexのためにrelativeに */
            z-index: 2; /* 崩れる文字が手前になるように */
            pointer-events: none; /* アニメーション中にマウスイベントを受け付けない */
        }

        @keyframes fadeInText {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes fall-from-center { /* 中央から広がるアニメーション */
            0% {
                opacity: 1;
                transform: translateY(0) rotate(0deg);
            }
            100% {
                opacity: 0;
                transform: translateY(calc(50vh + var(--randY))) translateX(calc(var(--randX))) rotate(var(--randRot)); /* 画面外へランダムに落下・回転 */
            }
        }

        .remaining-text-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Storyteller', cursive;
            font-size: 0; /* 初期サイズを0 */
            color: #000000;
            white-space: nowrap;
            z-index: 1; /* 奥に配置 */
            opacity: 0; /* 初期状態は完全に透明 */
            pointer-events: none; /* アニメーション中はマウスイベントを受け付けない */
        }

        .remaining-char {
            display: inline-block;
            opacity: 0;
            /* initial position & scale for assemble animation */
            transform: translate(var(--x, 0), var(--y, 0)) scale(0) rotate(var(--rot, 0deg));
            position: absolute; /* 各文字を絶対配置にしてバラバラにする */
            white-space: nowrap;
        }

        /* アニメーション後の状態 */
        .remaining-text-container.show {
            opacity: 1; /* コンテナ全体を不透明にする */
        }

        .remaining-text-container.show .remaining-char {
            animation: assembleAndGrow 1.5s forwards ease-out;
            /* animation-delay はJSで設定 */
        }

        @keyframes assembleAndGrow {
            0% {
                opacity: 0;
                transform: translate(var(--x), var(--y)) scale(0) rotate(var(--rot)); /* バラバラの開始位置 */
            }
            50% {
                opacity: 1;
                transform: translate(0, 0) scale(1.2) rotate(0deg); /* 中央に集まる */
            }
            100% {
                opacity: 1;
                transform: translate(0, 0) scale(1) rotate(0deg); /* 整列して最終サイズ */
                font-size: 80px; /* 最終的なフォントサイズ */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="text-wrapper" id="animatedText">
            </div>
        <div class="remaining-text-container" id="remainingText">
            </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const animatedTextElement = document.getElementById('animatedText');
            const remainingTextContainer = document.getElementById('remainingText');

            const initialText = `FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR
FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR
FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR`;

            const remainingText = "Storyteller";

            // 崩れ落ちる文字を動的に生成
            initialText.split('').forEach((char, index) => {
                const span = document.createElement('span');
                span.classList.add('falling-char');
                span.textContent = char;
                // 各文字のランダムな落下位置と回転を設定
                span.style.setProperty('--randX', `${(Math.random() - 0.5) * 500}px`); /* -250px から 250px */
                span.style.setProperty('--randY', `${Math.random() * 500}px`); /* 0px から 500px */
                span.style.setProperty('--randRot', `${Math.random() * 720 - 360}deg`); /* -360deg から 360deg */
                animatedTextElement.appendChild(span);
            });

            // 残る文字を動的に生成し、ランダムな初期位置を設定
            remainingText.split('').forEach(char => {
                const span = document.createElement('span');
                span.classList.add('remaining-char');
                span.textContent = char;

                // ランダムな初期位置と回転を設定（中央からの相対位置）
                const randomX = Math.random() * 400 - 200; // -200pxから200pxの範囲
                const randomY = Math.random() * 400 - 200;
                const randomRot = Math.random() * 360;

                span.style.setProperty('--x', `${randomX}px`);
                span.style.setProperty('--y', `${randomY}px`);
                span.style.setProperty('--rot', `${randomRot}deg`);

                remainingTextContainer.appendChild(span);
            });

            // ページロードから3秒後にアニメーションを開始
            const startDelay = 3000; // 3秒 = 3000ミリ秒
            const perCharFallDelay = 0.01; // 各文字の落下開始遅延
            const fallAnimationDuration = 2; // falling-charのアニメーションduration
            const assembleAndGrowDuration = 1.5; // remaining-charのアニメーションduration

            setTimeout(() => {
                // 崩れる文字のアニメーションを開始
                const fallingChars = document.querySelectorAll('.falling-char');
                fallingChars.forEach((char, index) => {
                    char.style.animation = `fall-from-center ${fallAnimationDuration}s forwards`;
                    char.style.animationDelay = `${perCharFallDelay * index}s`;
                });

                // 崩れるアニメーションの完了を待ってから残る文字を表示＆アニメーション
                const longestFallingAnimationEndTime = (initialText.length - 1) * perCharFallDelay * 1000 + fallAnimationDuration * 1000;

                setTimeout(() => {
                    remainingTextContainer.classList.add('show'); // コンテナ全体を不透明にする
                    const remainingChars = document.querySelectorAll('.remaining-char');
                    remainingChars.forEach((char, index) => {
                        // 各文字にアニメーションを適用
                        char.style.animationDelay = `${index * 0.1}s`; // 文字ごとに少し遅延
                        char.style.fontSize = `80px`; // アニメーション終了時のフォントサイズを設定 (CSSのkeyframesで制御されるが、念のため)
                    });
                }, longestFallingAnimationEndTime); // 崩れるアニメーション終了と同時に次のアニメーション開始
            }, startDelay); // ここで3秒の遅延を設定
        });
    </script>
</body>
</html>
