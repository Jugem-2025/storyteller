<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Text Animation</title>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;500&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #E81F27;
            font-family: 'Oswald', sans-serif;
            color: black; /* 文字色を黒に設定 */
            margin: 0;
            overflow: hidden; /* 崩れる文字がはみ出さないように */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            position: relative;
        }

        #initial-text-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%; /* テキストが収まるように調整 */
            text-align: center;
            line-height: 1.2;
            font-size: 2.5vw; /* 画面サイズに合わせて調整 */
            user-select: none; /* 文字選択を防止 */
            z-index: 10;
            opacity: 1;
        }

        .char-wrapper {
            display: inline-block;
            position: relative;
            white-space: pre; /* 空白が連続してもそのまま表示されるように */
        }

        .falling-char {
            position: absolute;
            left: 0;
            top: 0;
            transform: translate(0, 0);
            opacity: 1;
            transition: opacity 0.5s ease-out; /* フェードアウト用 */
            pointer-events: none; /* クリック不可に */
            user-select: none;
            color: black; /* 崩れる文字の色も黒に */
        }

        /* remaining-charはfinal-storyteller内のspanに適用 */
        .remaining-char {
            display: inline-block; /* flex itemとして機能させるため */
            transform: scale(1); /* 初期スケール */
            opacity: 1;
            font-size: inherit; /* 親からフォントサイズを継承 */
            white-space: pre; /* 空白が連続してもそのまま表示されるように */
            color: black; /* 残る文字の色も黒に */
        }

        #pile-container {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100px; /* 積もる領域の目安 */
            overflow: hidden;
            z-index: 5;
            pointer-events: none;
        }

        .piled-char {
            position: absolute;
            color: black; /* 積もった文字の色も黒に */
            opacity: 1;
            transition: opacity 2s ease-out; /* 積もった文字のフェードアウト */
            pointer-events: none;
            user-select: none;
        }

        #final-storyteller {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1);
            white-space: nowrap;
            opacity: 0; /* 最初は非表示 */
            z-index: 20;
            pointer-events: none;
            display: flex; /* 文字を横に並べるためにflexboxを使用 */
            justify-content: center;
            align-items: center;
            font-size: 2.5vw; /* 初期サイズは他の文字に合わせる */
            /* アニメーションプロパティ */
            transition: transform 2s ease-in-out, letter-spacing 2s ease-in-out, opacity 0.5s ease-out; /* opacityもtransition対象に */
        }

        /* 拡大と文字間隔調整のためのクラス */
        #final-storyteller.animate-final {
            transform: translate(-50%, -50%) scale(3);
            letter-spacing: 0.15em; /* 拡大に合わせて文字間隔を調整 */
            opacity: 1; /* アニメーション開始で表示 */
        }
    </style>
</head>
<body>
    <div id="initial-text-container"></div>
    <div id="pile-container"></div>
    <div id="final-storyteller"></div>

    <script>
        const initialText = `FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR
FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR
FENG SHUI MASTER / BARBER BORDER HOPPER / MATCHMAKER / NEW YORKER AUXILIARY POLICE TAILOR / DRONE PILOT TEA HOUSE OWNER STREET ARTIST / MONK NEW YORKER / TAILOR / SOCIAL WORKER CHEESE ARTISAN / FORTUNE TELLER / PRIEST MONK STORYTELLER / KUNG FU MASTER / HOMELESS MATCHMAKER / PRESCHOOL TEACHER
GRAFFITI ARTIST FENG SHUI MASTER
PRIEST / JUDGE ENGLISH TEACHER / BORDER HOPPER NEW YORKER COMMUNITY LEADER / SOCIAL WORKER NOVELIST NEW YORKER CHINESE MEDICINE DOCTOR / CHEESE ARTISAN STREET ARTIST JOURNALIST / AUXILIARY POLICE PROFESSOR
DRONE PILOT NEW YORKER / FENG SHUI MASTER STORYTELLER
MURALIST BORDER HOPPER / TEA HOUSE OWNER / CHEESE ARTISAN / JUDGE
SOCIAL WORKER JEWELER / NOVELIST / PRIEST / MURALIST
COMMUNITY MEMBER / ENGLISH TEACHER BARBER
GRAFFITI ARTIST / PROFESSOR SOCIAL WORKER TAILOR
ENGLISH TEACHER MATCHMAKER HOMELESS
HOMELESS STREET SINGER / STORYTELLER MONK
STREET ARTIST CHINESE MEDICINE DOCTOR / BARBER PROFESSOR`;

        const initialTextContainer = document.getElementById('initial-text-container');
        const pileContainer = document.getElementById('pile-container');
        const finalStoryteller = document.getElementById('final-storyteller');

        const targetChars = ['S', 't', 'o', 'r', 'y', 't', 'e', 'l', 'l', 'e', 'r']; // 'S'を大文字に変更
        let charElements = [];
        let remainingCharIndices = [];
        let completedFallingChars = 0;
        let totalFallingChars = 0;

        // 文字をspanでラップしてDOMに追加
        function setupInitialText() {
            let tempHTML = '';
            for (let i = 0; i < initialText.length; i++) {
                const char = initialText[i];
                if (char === ' ' || char === '\n') {
                    tempHTML += `<span class="char-wrapper" data-char="${char}">`;
                    tempHTML += (char === ' ') ? '&nbsp;' : '<br>';
                    tempHTML += '</span>';
                } else {
                    tempHTML += `<span class="char-wrapper" data-char="${char}">${char}</span>`;
                }
            }
            initialTextContainer.innerHTML = tempHTML;
            charElements = Array.from(initialTextContainer.querySelectorAll('.char-wrapper'));

            // 残す文字のインデックスを決定（バラけた場所で）
            let tempRemainingIndices = [];
            
            targetChars.forEach(targetChar => {
                let availableIndices = [];
                // ターゲット文字と一致し、かつまだ選ばれていない文字を探す
                for (let i = 0; i < charElements.length; i++) {
                    const charElement = charElements[i];
                    const charToCheck = (targetChar === 'S') ? charElement.dataset.char : charElement.dataset.char.toLowerCase();
                    
                    if (!tempRemainingIndices.includes(i) && charToCheck === targetChar.toLowerCase()) {
                        // 'S'の場合のみ、元のテキストの'S'と完全に一致するものを探す
                        // それ以外は小文字で比較して、大文字・小文字を区別しない
                        if (targetChar === 'S' && charElement.dataset.char === 'S') {
                            availableIndices.push(i);
                        } else if (targetChar !== 'S' && charToCheck === targetChar) {
                             availableIndices.push(i);
                        }
                    }
                }

                if (availableIndices.length > 0) {
                    // 既に選ばれたインデックスと最も距離があるものを優先
                    let bestIndex = -1;
                    let maxMinDistance = -1;

                    // availableIndices をシャッフルしてランダム性を高める
                    for (let i = availableIndices.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [availableIndices[i], availableIndices[j]] = [availableIndices[j], availableIndices[i]];
                    }

                    for (const currentIdx of availableIndices) {
                        if (tempRemainingIndices.length === 0) {
                            bestIndex = currentIdx;
                            break;
                        } else {
                            let minDistance = Infinity;
                            for (const selectedIdx of tempRemainingIndices) {
                                minDistance = Math.min(minDistance, Math.abs(currentIdx - selectedIdx));
                            }
                            if (minDistance > maxMinDistance) {
                                maxMinDistance = minDistance;
                                bestIndex = currentIdx;
                            }
                        }
                    }
                    if (bestIndex !== -1) {
                        tempRemainingIndices.push(bestIndex);
                    } else {
                        console.warn(`Target character '${targetChar}' could not be placed non-continuously.`);
                    }
                } else {
                    console.warn(`Target character '${targetChar}' not found in text.`);
                }
            });
            remainingCharIndices = tempRemainingIndices;

            // 最終的に表示されるstorytellerの文字を作成
            finalStoryteller.innerHTML = targetChars.map(char => `<span class="remaining-char">${char}</span>`).join('');
            finalStoryteller.style.opacity = 0; // 初期は非表示
        }


        // 文字を崩すアニメーション
        function startFallingAnimation() {
            charElements.forEach((charElement, index) => {
                if (!remainingCharIndices.includes(index)) {
                    totalFallingChars++; // 崩れる文字の総数をカウント
                }
            });

            const initialTextContainerRect = initialTextContainer.getBoundingClientRect();
            const startX = initialTextContainerRect.left + initialTextContainerRect.width / 6; // 左1/3あたり
            const startY = initialTextContainerRect.top + 20; // 上部から少し下

            let currentDelay = 0;
            const delayIncrement = 15; // 崩壊の広がりを制御する遅延の増分（ミリ秒）
            const decayRadiusIncrement = 0.5; // 崩壊範囲の広がり速度
            const maxDecayRadius = Math.max(initialTextContainerRect.width, initialTextContainerRect.height) / 2; // 最大崩壊半径

            let processedChars = new Set(); // 既にアニメーションがスケジュールされた文字のインデックスを保持

            const animateChar = (index) => {
                if (processedChars.has(index)) return;
                processedChars.add(index);

                const charElement = charElements[index];
                const char = charElement.dataset.char;

                if (!remainingCharIndices.includes(index)) {
                    const rect = charElement.getBoundingClientRect();
                    const initialX = rect.left + window.scrollX;
                    const initialY = rect.top + window.scrollY;
                    const fontSize = parseFloat(window.getComputedStyle(charElement).fontSize);

                    const fallingCharDiv = document.createElement('div');
                    fallingCharDiv.classList.add('falling-char');
                    fallingCharDiv.textContent = char === '\n' ? '' : char;
                    fallingCharDiv.style.cssText = `
                        position: fixed;
                        left: ${initialX}px;
                        top: ${initialY}px;
                        font-size: ${fontSize}px;
                        pointer-events: none;
                        user-select: none;
                        z-index: 10;
                    `;
                    document.body.appendChild(fallingCharDiv);

                    charElement.style.opacity = 0;

                    const duration = Math.random() * 0.5 + 1.0; // 1.0秒から1.5秒に調整 (速すぎないように)
                    const targetY = window.innerHeight - (Math.random() * 50 + 20);
                    const targetX = Math.random() * (window.innerWidth - fontSize * 2) + fontSize;

                    fallingCharDiv.animate([
                        { transform: 'translate(0, 0)', opacity: 1 },
                        { transform: `translate(${targetX - initialX}px, ${targetY - initialY}px)`, opacity: 1 }
                    ], {
                        duration: duration * 1000,
                        delay: currentDelay, // 崩壊の広がりと連動
                        easing: 'linear', // 落ちるスピードを一定に
                        fill: 'forwards'
                    }).onfinish = () => {
                        const piledChar = document.createElement('div');
                        piledChar.classList.add('piled-char');
                        piledChar.textContent = char === '\n' ? '' : char;
                        piledChar.style.cssText = `
                            left: ${targetX}px;
                            top: ${targetY}px;
                            font-size: ${fontSize}px;
                        `;
                        pileContainer.appendChild(piledChar);
                        fallingCharDiv.remove();

                        completedFallingChars++;
                        if (completedFallingChars === totalFallingChars) {
                            startPileFadeOutAndStorytellerAnimation();
                        }
                    };
                } else {
                    charElement.style.color = 'black';
                }
            };

            // 崩壊の起点となる文字からアニメーションをスケジュール
            const queue = [];
            const visited = new Set();

            // 起点となる文字を見つける（画面左上1/3あたり）
            let initialDecayCharIndex = -1;
            for(let i = 0; i < charElements.length; i++) {
                const charRect = charElements[i].getBoundingClientRect();
                const charCenterX = charRect.left + charRect.width / 2;
                const charCenterY = charRect.top + charRect.height / 2;

                if (charCenterX < window.innerWidth / 3 && charCenterY < window.innerHeight / 2) {
                    initialDecayCharIndex = i;
                    break;
                }
            }

            if (initialDecayCharIndex === -1 && charElements.length > 0) {
                 // 見つからなければ最初の文字を起点とする
                initialDecayCharIndex = 0;
            }

            if (initialDecayCharIndex !== -1) {
                queue.push({ index: initialDecayCharIndex, delay: 0 });
                visited.add(initialDecayCharIndex);
            }

            let head = 0;
            while (head < queue.length) {
                const { index: currentIdx, delay: currentCharDelay } = queue[head++];
                animateChar(currentIdx);

                // 隣接する文字を探索（周囲の文字をランダムに含める）
                const neighbors = [];
                const maxRange = 300; // 近くの文字を探す範囲

                for (let i = 0; i < charElements.length; i++) {
                    if (i === currentIdx || visited.has(i)) continue;

                    const rect1 = charElements[currentIdx].getBoundingClientRect();
                    const rect2 = charElements[i].getBoundingClientRect();

                    const dist = Math.sqrt(Math.pow(rect1.left - rect2.left, 2) + Math.pow(rect1.top - rect2.top, 2));

                    if (dist < maxRange && Math.random() < 0.2) { // 20%の確率でランダムに広がる
                        neighbors.push(i);
                    }
                }

                // ランダムに選んだ隣接文字をキューに追加
                neighbors.forEach(nIdx => {
                    if (!visited.has(nIdx)) {
                        visited.add(nIdx);
                        queue.push({ index: nIdx, delay: currentCharDelay + delayIncrement + Math.random() * 50 }); // 少しランダムな遅延を追加
                    }
                });

                // 一定数の文字が処理されたら、次のバッチをスケジュール
                if (head % 50 === 0) { // 例: 50文字ごとに処理
                    currentDelay = currentCharacterDelay + 50; // 全体的な遅延を増やす
                }
            }
            initialTextContainer.style.opacity = 0; // 全体が消えるように
        }

        function startPileFadeOutAndStorytellerAnimation() {
            // 積もった文字をフェードアウト
            const piledChars = document.querySelectorAll('.piled-char');
            piledChars.forEach(char => {
                char.style.opacity = 0; // CSS transitionで2秒かけてフェードアウト
            });

            // 崩れ落ちなかった文字（storyteller）の表示と拡大を2秒後に開始
            setTimeout(() => {
                finalStoryteller.classList.add('animate-final'); // CSS transitionでアニメーション
            }, 2000); // フェードアウトの2秒後
        }

        // 初期化処理
        document.addEventListener('DOMContentLoaded', () => {
            setupInitialText();

            // 3秒後にアニメーション開始
            setTimeout(() => {
                startFallingAnimation();
            }, 3000);
        });
    </script>
</body>
</html>
